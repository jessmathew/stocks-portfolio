---
title: 'GR5261 - Statistical Methods in Finance: Stocks Portfolio'
author: 
  - Jess Mathew
  - jm4742
date: "June 4, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Libraries
```{r}
library(tools)
library(zoo)
library(forecast)
library(tidyverse)
library(PerformanceAnalytics)
library(dplyr)
library(corrr)
library(tseries)
library(xts)
library(quantmod)
library(PortfolioAnalytics)
library(ROI)
library(ROI.plugin.glpk)
library(ROI.plugin.quadprog)
library(ROI.plugin.symphony)
library(tsbox)
library(reshape2)
```

# Merge all the individual files together to create two datasets. (1) Date and Adjusted Close Price (2) Date and Volume
```{r eval=FALSE}
multMergeDateAndAdjustedClosePrice <- function(mypath) {
  filenames<-list.files(path=mypath, full.names=TRUE)
  datalist <- lapply(filenames, function(x){
    stockData <- read.csv(file=x,header=T)[,c("date", "adjclose")]
    colnames(stockData)[2] <- file_path_sans_ext(basename(x))
    return (stockData)
    })
  Reduce(function(x,y) {
    merge(x,y, by.x = "date", by.y = "date", all = TRUE)
    }, datalist)
}

multMergeDateAndVolume <- function(mypath) {
  filenames<-list.files(path=mypath, full.names=TRUE)
  datalist <- lapply(filenames, function(x){
    stockData <- read.csv(file=x,header=T)[,c("date", "volume")]
    colnames(stockData)[2] <- file_path_sans_ext(basename(x))
    return (stockData)
    })
  Reduce(function(x,y) {
    merge(x,y, by.x = "date", by.y = "date", all = TRUE)
    }, datalist)
}

dateAndAdjustedClosePriceData <- multMergeDateAndAdjustedClosePrice("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\AMEX NYSE NASDAQ Stock Histories\\fh_20190420\\full_history")

dateAndVolumeData <- multMergeDateAndVolume("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\AMEX NYSE NASDAQ Stock Histories\\fh_20190420\\full_history")

write.csv(dateAndAdjustedClosePriceData,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\DateAndAdjustedClosePriceData.csv", row.names = FALSE)

write.csv(dateAndVolumeData,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\DateAndVolumeData.csv", row.names = FALSE)
```

# Read the data files and order them by date.
```{r eval=FALSE}
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")

dateAndAdjustedClosePriceData <- read.csv(file="DateAndAdjustedClosePriceData.csv", header=TRUE, sep=",")
dateAndAdjustedClosePriceDataOrderedByDate <- dateAndAdjustedClosePriceData[order(dateAndAdjustedClosePriceData$date),]

dateAndVolumeData <- read.csv(file="DateAndVolumeData.csv", header=TRUE, sep=",")
dateAndVolumeDataOrderedByDate <- dateAndVolumeData[order(dateAndVolumeData$date),]

write.csv(dateAndAdjustedClosePriceDataOrderedByDate,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\DateAndAdjustedClosePriceDataOrderedByDate.csv", row.names = FALSE)

write.csv(dateAndVolumeDataOrderedByDate,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\DateAndVolumeDataOrderedByDate.csv", row.names = FALSE)
```

# Take the final ten years of data and remove assets which have five percent or more of the data missing. Remove assets which have less than 1,000 volume for 5% or more of the ten year period.
```{r eval=FALSE}
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")
dateAndAdjustedClosePriceDataOrderedByDate <- read.csv(file="DateAndAdjustedClosePriceDataOrderedByDate.csv", header=TRUE, sep=",")
dateAndVolumeDataOrderedByDate <- read.csv(file="DateAndVolumeDataOrderedByDate.csv", header=TRUE, sep=",")

numberOfDays <- nrow(dateAndAdjustedClosePriceDataOrderedByDate)
financialDaysInYear <- 252
financialDaysInTenYears <- financialDaysInYear*10

lastDayInTheFinalTenYearPeriod <- numberOfDays
firstDayInTheFinalTenYearPeriod <- lastDayInTheFinalTenYearPeriod - financialDaysInTenYears

dateAndAdjustedClosePriceDataOrderedByDateForFinalTenYearPeriod <- dateAndAdjustedClosePriceDataOrderedByDate[firstDayInTheFinalTenYearPeriod:lastDayInTheFinalTenYearPeriod, ]

columnNamesWithNinetyFivePercentOfAdjustedClosePriceDataAvailable <- colnames(dateAndAdjustedClosePriceDataOrderedByDateForFinalTenYearPeriod)[as.data.frame(colSums(is.na(dateAndAdjustedClosePriceDataOrderedByDateForFinalTenYearPeriod))/financialDaysInTenYears) <= 0.05]

dateAndVolumeDataOrderedByDateForFinalTenYearPeriod <- dateAndVolumeDataOrderedByDate[firstDayInTheFinalTenYearPeriod:lastDayInTheFinalTenYearPeriod, ]
dateAndVolumeDataOrderedByDateForFinalTenYearPeriod[is.na(dateAndVolumeDataOrderedByDateForFinalTenYearPeriod)] <- 0
dateAndVolumeDataOrderedByDateForFinalTenYearPeriod <- apply(dateAndVolumeDataOrderedByDateForFinalTenYearPeriod, 2, function(x) ifelse(x < 1000, "NA", x))

columnNamesWithNinetyFivePercentOfVolumeDataNotLiquid <- colnames(dateAndVolumeDataOrderedByDateForFinalTenYearPeriod)[as.data.frame(colSums(is.na(dateAndVolumeDataOrderedByDateForFinalTenYearPeriod))/financialDaysInTenYears) <= 0.05]

columnNamesForStocksThatAreVettedToUseInAnalysis <- intersect(as.vector(columnNamesWithNinetyFivePercentOfAdjustedClosePriceDataAvailable), as.vector(columnNamesWithNinetyFivePercentOfAdjustedClosePriceDataAvailable))

finalTenYearsStockHistoryForRelevantStocksConsecutiveNAValues <- subset(dateAndAdjustedClosePriceDataOrderedByDateForFinalTenYearPeriod, select=columnNamesForStocksThatAreVettedToUseInAnalysis)

write.csv(finalTenYearsStockHistoryForRelevantStocksConsecutiveNAValues,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\FinalTenYearsStockHistoryForRelevantStocksConsecutiveNAValues.csv", row.names = FALSE)
```

# Remove assets where there are too many consecutive NA values
```{r eval=FALSE}
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")
finalTenYearsStockHistoryData <- read.csv(file="FinalTenYearsStockHistoryForRelevantStocksConsecutiveNAValues.csv", header=TRUE, sep=",")

columnIndexes <- seq(1,ncol(finalTenYearsStockHistoryData))

columnIndexesWhereConsecutiveNAsAreGreaterThanOrEqualToTen <- c()
for (columnIndex in columnIndexes)
{
  stockDataForIteration <- finalTenYearsStockHistoryData[,columnIndex]
  naBreakdown <- rle(is.na(stockDataForIteration))
  if(naBreakdown$lengths >= 10 & naBreakdown$values == TRUE) {
      columnIndexesWhereConsecutiveNAsAreGreaterThanOrEqualToTen[columnIndex] <- -columnIndex
    }
}
columnIndexesWhereConsecutiveNAsAreGreaterThanOrEqualToTen <- columnIndexesWhereConsecutiveNAsAreGreaterThanOrEqualToTen[!is.na(columnIndexesWhereConsecutiveNAsAreGreaterThanOrEqualToTen)]

finalTenYearsStockHistoryData <- finalTenYearsStockHistoryData[columnIndexesWhereConsecutiveNAsAreGreaterThanOrEqualToTen]

write.csv(finalTenYearsStockHistoryData,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\FinalTenYearsStockHistoryForRelevantStocksNoNAValues.csv", row.names = FALSE)
```

# Fill in the missing NA values with reasonable estimates. For the columns where NA is the first value, we need to manually delete those. Approximately 3 columns with 10 NA values in total between the 3 columns.
```{r eval=FALSE}
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")
finalTenYearsStockHistoryData <- read.csv(file="FinalTenYearsStockHistoryForRelevantStocksNoNAValues.csv", header=TRUE, sep=",")

columnNames <- colnames(finalTenYearsStockHistoryData)

for (columnName in columnNames)
{
  finalTenYearsStockHistoryData <- finalTenYearsStockHistoryData %>% fill(columnName) #default direction down
}

write.csv(finalTenYearsStockHistoryData,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\FilteredStockHistoryDataForTheFinalTenYearsWithNoGaps.csv", row.names = FALSE)
```

# Compute the daily log returns using adjusted close prices. 
```{r eval=FALSE}
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")
finalTenYearsStockHistoryData <- read.csv(file="FilteredStockHistoryDataForTheFinalTenYearsWithNoGaps.csv", header=TRUE, sep=",", colClasses=c("Date",rep("numeric",3909)))

dailyLogReturns <- data.frame(
   cbind.data.frame(
     finalTenYearsStockHistoryData$date[-1],
     diff(as.matrix(log(finalTenYearsStockHistoryData[,-1])))
     )
   )
names(dailyLogReturns)[1]<-"date"

write.csv(dailyLogReturns,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\FullLogStockAssetDataPossibleNAValues.csv", row.names = FALSE)
```

# Need to remove columns that have too many NA values in them at this point, in the log data file. Just remove all columns with NA's in them at this point, after taking the logs.
```{r eval=FALSE}
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")
finalTenYearsStockHistoryData <- read.csv(file="FullLogStockAssetDataPossibleNAValues.csv", header=TRUE, sep=",")

finalTenYearsStockHistoryData <- finalTenYearsStockHistoryData[ , colSums(is.na(finalTenYearsStockHistoryData)) == 0]

write.csv(finalTenYearsStockHistoryData,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\FullLogStockAssetDataFilteredForNA.csv", row.names = FALSE)
```

# Detect and replace the outliers with estimates that are more consistent with the majority of the data
```{r eval=FALSE}
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")
fullLogAssetData <- read.csv(file="FullLogStockAssetDataFilteredForNA.csv", header=TRUE, sep=",", colClasses=c("Date",rep("numeric",3906)))

winsor1 <- function (x, fraction=.05)
{
   if(length(fraction) != 1 || fraction < 0 ||
         fraction > 0.5) {
      stop("bad value for 'fraction'")
   }
   lim <- quantile(x, probs=c(fraction, 1-fraction))
   x[ x < lim[1] ] <- lim[1]
   x[ x > lim[2] ] <- lim[2]
   x
}

columnIndexes <- seq(2,ncol(fullLogAssetData))

for (columnIndex in columnIndexes) {
  fullLogAssetData[,columnIndex] <- winsor1(fullLogAssetData[,columnIndex])
}

write.csv(fullLogAssetData,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\FullLogStockAssetDataFittedForOutliers.csv", row.names = FALSE)
```

# Portfolio Optimization
```{r eval=FALSE}
options(scipen = 999)
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")
fittedFullLogAssetData <- read.csv(file="FullLogStockAssetDataFittedForOutliers.csv", header=TRUE, sep=",", colClasses=c("Date",rep("numeric",3906)))[-1,]

justTesting <- as.data.frame(colMeans(fittedFullLogAssetData[,-1]))

count(colSums(justTesting) < 0)
count(colSums(justTesting) >= 0)

numberOfRows <- nrow(fittedFullLogAssetData)
numberOfColumns <- ncol(fittedFullLogAssetData)

h <- 5
m <- 252

# breakingCondition <- numberOfRows + h

index <- 0

stockIndexesForFirstLoop <- seq(2,numberOfColumns)
listOftotalReturnsForEachForecastedPeriod <- list()
while (TRUE)
{
  print("While loop index")
  print(index)
  print(Sys.time())
  
  startRow <- (h*index) + 1
  endRow <- (h*index) + m
  
  assetsDataForCurrentTimePeriod <- fittedFullLogAssetData[startRow:endRow,]
  assetsDataForForecastedTimePeriod <- fittedFullLogAssetData[(endRow+1):(endRow+h),]
  
  #Sharpe Ratio Filtering
  sharpeRatiosWithStockIndex <- data.frame(Stock=character(), SharpeRatio= as.double(double()), stringsAsFactors=FALSE)[stockIndexesForFirstLoop,]
  
  for (stockIndexForFirstLoop in stockIndexesForFirstLoop)
  {
    currentAssetDataForStockIndex <- assetsDataForCurrentTimePeriod[,c(1,stockIndexForFirstLoop)]
    columnName <- colnames(currentAssetDataForStockIndex)[2]
    sharpeRatiosWithStockIndex[nrow(sharpeRatiosWithStockIndex)+1, ] <- c(columnName, (mean(currentAssetDataForStockIndex[,2]))/(sd(currentAssetDataForStockIndex[,2])))
  }
  
  stockNamesWithHighestSharpeRatios <- sharpeRatiosWithStockIndex %>% arrange(desc(SharpeRatio))
  stockNamesWithHighestSharpeRatios <- data.frame(head(stockNamesWithHighestSharpeRatios, 50))
  
  stocksWithHighestSharpeRatios <- subset(assetsDataForCurrentTimePeriod, select=stockNamesWithHighestSharpeRatios[,1])
  
  #Correlation Filtering
  correlationBetweenTheStocks <- stocksWithHighestSharpeRatios %>% correlate(use = "everything") %>% stretch() %>% arrange(abs(r))
  
  namesOfLowlyCorrelatedStocks <- data.frame(stack(correlationBetweenTheStocks[1:2]))[,1] %>% unique()
  namesOfLowlyCorrelatedStocks <- data.frame(head(namesOfLowlyCorrelatedStocks, 30))
  
  stocksToUseForModeling <- assetsDataForCurrentTimePeriod[, as.vector(namesOfLowlyCorrelatedStocks[,1])]
  stocksToUseForModelingWithDateAppended <- data.frame(assetsDataForCurrentTimePeriod[,1], stocksToUseForModeling)
  stocksToUseForModelingXTS <- xts(stocksToUseForModelingWithDateAppended[,-1], order.by=stocksToUseForModelingWithDateAppended[,1])
  
  stockIndexesForSecondLoop <- seq(1:ncol(stocksToUseForModeling))
  forecastedLogReturnsForStocksList = list()
  
  for(stockIndexForSecondLoop in stockIndexesForSecondLoop) {
    print("Second loop index")
    print(stockIndexForSecondLoop)
    currentStock <- stocksToUseForModeling[stockIndexForSecondLoop]

    columnName <- colnames(currentStock)
    
    currentStockTS <- ts(currentStock)
    currentStockTSFitted <- auto.arima(currentStockTS)
    currentStockForecasted <- forecast(currentStockTSFitted,h=h)$mean
    # forcastedLogReturnsForCurrentStock <- as.data.frame(currentStockForecasted)
    forcastedLogReturnsForCurrentStock <- as.data.frame(assetsDataForForecastedTimePeriod[,columnName])
    
    colnames(forcastedLogReturnsForCurrentStock)[colnames(forcastedLogReturnsForCurrentStock)=="x"] <- columnName
    forecastedLogReturnsForStocksList[[stockIndexForSecondLoop]] <- forcastedLogReturnsForCurrentStock
  }
  
  forecastedLogReturnsForStocks <- dplyr::bind_cols(forecastedLogReturnsForStocksList)
  forecastedLogReturnsForStocks <- as.matrix.data.frame(forecastedLogReturnsForStocks)
  
  tickers <- colnames(stocksToUseForModeling)
  
  # Black Litterman Model for Portfolio Optimization
  meanReturns <- colMeans(stocksToUseForModeling)
  covMat <- cov(stocksToUseForModeling)
  
  q <- matrix(c(0.041,0.016,0.008),3,1)
  P <- matrix(c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,-1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,-1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ), 3, 30, byrow = TRUE)
  sigma <- matrix(c(0.000801,0,0, 0,0.009546,0, 0,0,0.000884), 3,3, byrow = TRUE)
  tau = 0.025
  pi <- as.matrix(meanReturns)
  
  #Calculating the first term in BL method(Sum of weights = 1)
  tau_cov= tau*covMat
  weight_1 = ginv(tau_cov)
  P_transpose = t(P)
  sigma_inv = ginv(sigma)
  weight_2 <- P_transpose %*% sigma_inv %*% P
  first_term_before_inv = weight_1 + weight_2
  first_term = ginv(first_term_before_inv)
  
  #Calculating the second term in BL method(Sum of weighted Pi and Q)
  pi_component = weight_1 %*% pi
  q_component = P_transpose %*% sigma_inv %*% q
  second_term = pi_component + q_component
  
  #Final BL matrix
  BL_matrix = first_term %*% second_term
  
  #Define the QP
  Dmat_BL <- 2*covMat
  dvec_BL <- rep(0,30)
  Amat_BL <- matrix(c(BL_matrix,-BL_matrix,rep(1,30),rep(-1,30),diag(length(BL_matrix))),30,12)
  
  # compute efficient frontier for eight stocks
  varP_BL=vector()
  sigmaP_BL=vector()
  w1_BL=vector()
  w2_BL=vector()
  w3_BL=vector()
  w4_BL=vector()
  w5_BL=vector()
  w6_BL=vector()
  w7_BL=vector()
  w8_BL=vector()
  w9_BL=vector()
  w10_BL=vector()
  w11_BL=vector()
  w12_BL=vector()
  w13_BL=vector()
  w14_BL=vector()
  w15_BL=vector()
  w16_BL=vector()
  w17_BL=vector()
  w18_BL=vector()
  w19_BL=vector()
  w20_BL=vector()
  w21_BL=vector()
  w22_BL=vector()
  w23_BL=vector()
  w24_BL=vector()
  w25_BL=vector()
  w26_BL=vector()
  w27_BL=vector()
  w28_BL=vector()
  w29_BL=vector()
  w30_BL=vector()
  
  sc <- norm(Dmat_BL,"2")
  
  #Expected Returns 20 values
  Rvals_BL=seq(min(BL_matrix)+0.1^10,max(BL_matrix)-0.1^10,length.out=20)
  
  for (i in 1:length(Rvals_BL)) {
    R=Rvals_BL[i]
    bvec_BL <- c(R,-R,1,-1,0,0,0,0,0,0,0,0)
    qpSol_BL=solve.QP(Dmat_BL/10^6,dvec_BL/10^6,Amat_BL,bvec_BL, meq=0)
    varP_BL[i]=qpSol_BL$value
    sigmaP_BL[i]=sqrt(varP_BL[i])
    w1_BL[i]=qpSol_BL$solution[1];
    w2_BL[i]=qpSol_BL$solution[2];
    w3_BL[i]=qpSol_BL$solution[3];
    w4_BL[i]=qpSol_BL$solution[4];
    w5_BL[i]=qpSol_BL$solution[5];
    w6_BL[i]=qpSol_BL$solution[6];
    w7_BL[i]=qpSol_BL$solution[7];
    w8_BL[i]=qpSol_BL$solution[8];
    w9_BL[i]=qpSol_BL$solution[9];
    w10_BL[i]=qpSol_BL$solution[10];
    w11_BL[i]=qpSol_BL$solution[11];
    w12_BL[i]=qpSol_BL$solution[12];
    w13_BL[i]=qpSol_BL$solution[13];
    w14_BL[i]=qpSol_BL$solution[14];
    w15_BL[i]=qpSol_BL$solution[15];
    w16_BL[i]=qpSol_BL$solution[16];
    w17_BL[i]=qpSol_BL$solution[17];
    w18_BL[i]=qpSol_BL$solution[18];
    w19_BL[i]=qpSol_BL$solution[19];
    w20_BL[i]=qpSol_BL$solution[20];
    w21_BL[i]=qpSol_BL$solution[21];
    w22_BL[i]=qpSol_BL$solution[22];
    w23_BL[i]=qpSol_BL$solution[23];
    w24_BL[i]=qpSol_BL$solution[24];
    w25_BL[i]=qpSol_BL$solution[25];
    w26_BL[i]=qpSol_BL$solution[26];
    w27_BL[i]=qpSol_BL$solution[27];
    w28_BL[i]=qpSol_BL$solution[28];
    w29_BL[i]=qpSol_BL$solution[29];
    w30_BL[i]=qpSol_BL$solution[30];
  }
  
  #Portfolio weights
  weightsoutput<-data.frame(w1_BL,w2_BL,w3_BL,w4_BL,w5_BL,w6_BL,w7_BL,w8_BL,w9_BL,w10_BL,w11_BL,w12_BL,w13_BL,w14_BL,w15_BL,w16_BL,w17_BL,w18_BL,w19_BL,w20_BL,w21_BL,w22_BL,w23_BL,w24_BL,w25_BL,w26_BL,w27_BL,w28_BL,w29_BL,w30_BL)
  
  weightsAverage <- as.data.frame(colMeans(weightsoutput))
  
  # print(dim(weightsAverage))
  
  
  columnSumsOfStocksToUseForModeling <- as.data.frame(colSums(stocksToUseForModeling))
  weightsForPortfolio <- as.data.frame(sweep(columnSumsOfStocksToUseForModeling,2,colSums(columnSumsOfStocksToUseForModeling),`/`))
  
  print(dim(forecastedLogReturnsForStocks))
  print(dim(weightsAverage))
  
  totalReturnsForTheForecastingWindowByDay <- as.matrix(forecastedLogReturnsForStocks) %*% as.matrix(weightsAverage)
  
  totalReturnForTheForecastingWindow <- unname(colSums(totalReturnsForTheForecastingWindowByDay))
  listOftotalReturnsForEachForecastedPeriod[[index+1]] <- totalReturnForTheForecastingWindow
  
  index <- index + 1
  if (index == 455)
  # if (endRow > 257)
  {
    break
  }
}

totalReturnsForEachForecastedPeriod <- dplyr::bind_cols(listOftotalReturnsForEachForecastedPeriod)
totalReturnsForEachForecastedPeriod <- as.data.frame(totalReturnsForEachForecastedPeriod)

totalReturnsForEachForecastedPeriod

write.csv(totalReturnsForEachForecastedPeriod,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\TESTForecastedPortfolioReturns.csv", row.names = FALSE)
```

# Portfolio Optimization with Equal Weights
```{r eval=FALSE}
options(scipen = 999)
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")
fittedFullLogAssetData <- read.csv(file="FullLogStockAssetDataFittedForOutliers.csv", header=TRUE, sep=",", colClasses=c("Date",rep("numeric",3906)))[-1,]

justTesting <- as.data.frame(colMeans(fittedFullLogAssetData[,-1]))

count(colSums(justTesting) < 0)
count(colSums(justTesting) >= 0)

numberOfRows <- nrow(fittedFullLogAssetData)
numberOfColumns <- ncol(fittedFullLogAssetData)

h <- 5
m <- 252

# breakingCondition <- numberOfRows + h

index <- 0

stockIndexesForFirstLoop <- seq(2,numberOfColumns)
listOftotalReturnsForEachForecastedPeriod <- list()
while (TRUE)
{
  print("While loop index")
  print(index)
  print(Sys.time())
  
  startRow <- (h*index) + 1
  endRow <- (h*index) + m
  
  assetsDataForCurrentTimePeriod <- fittedFullLogAssetData[startRow:endRow,]
  assetsDataForForecastedTimePeriod <- fittedFullLogAssetData[(endRow+1):(endRow+h),]
  
  #Sharpe Ratio Filtering
  sharpeRatiosWithStockIndex <- data.frame(Stock=character(), SharpeRatio= as.double(double()), stringsAsFactors=FALSE)[stockIndexesForFirstLoop,]
  
  for (stockIndexForFirstLoop in stockIndexesForFirstLoop)
  {
    currentAssetDataForStockIndex <- assetsDataForCurrentTimePeriod[,c(1,stockIndexForFirstLoop)]
    columnName <- colnames(currentAssetDataForStockIndex)[2]
    sharpeRatiosWithStockIndex[nrow(sharpeRatiosWithStockIndex)+1, ] <- c(columnName, (mean(currentAssetDataForStockIndex[,2]))/(sd(currentAssetDataForStockIndex[,2])))
  }
  
  stockNamesWithHighestSharpeRatios <- sharpeRatiosWithStockIndex %>% arrange(desc(SharpeRatio))
  stockNamesWithHighestSharpeRatios <- data.frame(head(stockNamesWithHighestSharpeRatios, 50))
  
  stocksWithHighestSharpeRatios <- subset(assetsDataForCurrentTimePeriod, select=stockNamesWithHighestSharpeRatios[,1])
  
  #Correlation Filtering
  correlationBetweenTheStocks <- stocksWithHighestSharpeRatios %>% correlate(use = "everything") %>% stretch() %>% arrange(abs(r))
  
  namesOfLowlyCorrelatedStocks <- data.frame(stack(correlationBetweenTheStocks[1:2]))[,1] %>% unique()
  namesOfLowlyCorrelatedStocks <- data.frame(head(namesOfLowlyCorrelatedStocks, 30))
  
  stocksToUseForModeling <- assetsDataForCurrentTimePeriod[, as.vector(namesOfLowlyCorrelatedStocks[,1])]
  stocksToUseForModelingWithDateAppended <- data.frame(assetsDataForCurrentTimePeriod[,1], stocksToUseForModeling)
  stocksToUseForModelingXTS <- xts(stocksToUseForModelingWithDateAppended[,-1], order.by=stocksToUseForModelingWithDateAppended[,1])
  
  stockIndexesForSecondLoop <- seq(1:ncol(stocksToUseForModeling))
  forecastedLogReturnsForStocksList = list()
  
  for(stockIndexForSecondLoop in stockIndexesForSecondLoop) {
    print("Second loop index")
    print(stockIndexForSecondLoop)
    currentStock <- stocksToUseForModeling[stockIndexForSecondLoop]
    
    columnName <- colnames(currentStock)
    
    currentStockTS <- ts(currentStock)
    currentStockTSFitted <- auto.arima(currentStockTS)
    currentStockForecasted <- forecast(currentStockTSFitted,h=h)$mean
    # forcastedLogReturnsForCurrentStock <- as.data.frame(currentStockForecasted)
    forcastedLogReturnsForCurrentStock <- as.data.frame(assetsDataForForecastedTimePeriod[,columnName])
    
    colnames(forcastedLogReturnsForCurrentStock)[colnames(forcastedLogReturnsForCurrentStock)=="x"] <- columnName
    forecastedLogReturnsForStocksList[[stockIndexForSecondLoop]] <- forcastedLogReturnsForCurrentStock
  }
  
  forecastedLogReturnsForStocks <- dplyr::bind_cols(forecastedLogReturnsForStocksList)
  forecastedLogReturnsForStocks <- as.matrix.data.frame(forecastedLogReturnsForStocks)
  
  tickers <- colnames(stocksToUseForModeling)
  
  # Black Litterman Model for Portfolio Optimization
  meanReturns <- colMeans(stocksToUseForModeling)
  covMat <- cov(stocksToUseForModeling)
  
  weightsForPortfolio <- data.frame(matrix(ncol = 1, nrow = 30))
  weightsForPortfolio[] <- 1/30
  
  totalReturnsForTheForecastingWindowByDay <- as.matrix(forecastedLogReturnsForStocks) %*% as.matrix(weightsForPortfolio)
  
  totalReturnForTheForecastingWindow <- unname(colSums(totalReturnsForTheForecastingWindowByDay))
  listOftotalReturnsForEachForecastedPeriod[[index+1]] <- totalReturnForTheForecastingWindow
  
  index <- index + 1
  if (index == 455)
    # if (endRow > 257)
  {
    break
  }
}

totalReturnsForEachForecastedPeriod <- dplyr::bind_cols(listOftotalReturnsForEachForecastedPeriod)
totalReturnsForEachForecastedPeriod <- as.data.frame(totalReturnsForEachForecastedPeriod)

totalReturnsForEachForecastedPeriod

write.csv(totalReturnsForEachForecastedPeriod,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\TESTForecastedPortfolioReturnsEqualWeights.csv", row.names = FALSE)
``` 

# Portfolio Optimization for S&P500
```{r eval=FALSE}
options(scipen = 999)
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")

sp500StockData <- read.csv(file = "SP500new.csv", header=TRUE, sep=",", colClasses=c("Date",rep("numeric",5)))

numberOfDays <- nrow(sp500StockData)
financialDaysInYear <- 252
financialDaysInTenYears <- financialDaysInYear*10

lastDayInTheFinalTenYearPeriod <- numberOfDays
firstDayInTheFinalTenYearPeriod <- lastDayInTheFinalTenYearPeriod - financialDaysInTenYears

sp500StockDataForFinalTenYearPeriod <- sp500StockData[firstDayInTheFinalTenYearPeriod:lastDayInTheFinalTenYearPeriod, c(1, 4)]

fittedFullLogSP500StockData <- data.frame(
  cbind.data.frame(
    sp500StockDataForFinalTenYearPeriod$Date[-1],
    diff(as.matrix(log(sp500StockDataForFinalTenYearPeriod[,-1])))
  )
)
names(sp500StockDataForFinalTenYearPeriod)[1]<-"date"

head(fittedFullLogSP500StockData)
dim(fittedFullLogSP500StockData)

fittedFullLogAssetData = cbind(fittedFullLogSP500StockData, replicate(30,fittedFullLogSP500StockData[,2]))

head(fittedFullLogAssetData)

# fittedFullLogAssetData <- read.csv(file="FullLogStockAssetDataFittedForOutliers.csv", header=TRUE, sep=",", colClasses=c("Date",rep("numeric",3906)))[-1,]
numberOfRows <- nrow(fittedFullLogAssetData)
numberOfColumns <- ncol(fittedFullLogAssetData)

h <- 5
m <- 252

# breakingCondition <- numberOfRows + h

index <- 0

stockIndexesForFirstLoop <- seq(2,numberOfColumns)
listOftotalReturnsForEachForecastedPeriod <- list()
while (TRUE)
{
  print("While loop index")
  print(index)
  print(Sys.time())
  startRow <- (h*index) + 1
  endRow <- (h*index) + m
  
  assetsDataForCurrentTimePeriod <- fittedFullLogAssetData[startRow:endRow,]
  assetsDataForForecastedTimePeriod <- fittedFullLogAssetData[(endRow+1):(endRow+h),]
  
  sharpeRatiosWithStockIndex <- data.frame(Stock=character(), SharpeRatio= as.double(double()), stringsAsFactors=FALSE)[stockIndexesForFirstLoop,]
  
  for (stockIndexForFirstLoop in stockIndexesForFirstLoop)
  {
    currentAssetDataForStockIndex <- assetsDataForCurrentTimePeriod[,c(1,stockIndexForFirstLoop)]
    columnName <- colnames(currentAssetDataForStockIndex)[2]
    sharpeRatiosWithStockIndex[nrow(sharpeRatiosWithStockIndex)+1, ] <- c(columnName, (mean(currentAssetDataForStockIndex[,2]))/(sd(currentAssetDataForStockIndex[,2])))
  }
  
  stockNamesWithHighestSharpeRatios <- sharpeRatiosWithStockIndex %>% arrange(desc(SharpeRatio))
  stockNamesWithHighestSharpeRatios <- data.frame(head(stockNamesWithHighestSharpeRatios, 30))
  
  stocksWithHighestSharpeRatios <- subset(assetsDataForCurrentTimePeriod, select=stockNamesWithHighestSharpeRatios[,1])
  
  correlationBetweenTheStocks <- stocksWithHighestSharpeRatios %>% correlate(use = "everything") %>% stretch() %>% arrange(abs(r))
  
  namesOfLowlyCorrelatedStocks <- data.frame(stack(correlationBetweenTheStocks[1:2]))[,1] %>% unique()
  namesOfLowlyCorrelatedStocks <- data.frame(head(namesOfLowlyCorrelatedStocks, 30))
  
  stocksToUseForModeling <- assetsDataForCurrentTimePeriod[, as.vector(namesOfLowlyCorrelatedStocks[,1])]
  stocksToUseForModelingWithDateAppended <- data.frame(assetsDataForCurrentTimePeriod[,1], stocksToUseForModeling)
  stocksToUseForModelingXTS <- xts(stocksToUseForModelingWithDateAppended[,-1], order.by=stocksToUseForModelingWithDateAppended[,1])
  
  stockIndexesForSecondLoop <- seq(1:ncol(stocksToUseForModeling))
  forecastedLogReturnsForStocksList = list()
  
  for(stockIndexForSecondLoop in stockIndexesForSecondLoop) {
    print("Second loop index")
    print(stockIndexForSecondLoop)
    currentStock <- stocksToUseForModeling[stockIndexForSecondLoop]
    
    columnName <- colnames(currentStock)
    
    currentStockTS <- ts(currentStock)
    currentStockTSFitted <- auto.arima(currentStockTS)
    currentStockForecasted <- forecast(currentStockTSFitted,h=h)$mean
    # forcastedLogReturnsForCurrentStock <- as.data.frame(currentStockForecasted)
    forcastedLogReturnsForCurrentStock <- as.data.frame(assetsDataForForecastedTimePeriod[,columnName])
    
    colnames(forcastedLogReturnsForCurrentStock)[colnames(forcastedLogReturnsForCurrentStock)=="x"] <- columnName
    forecastedLogReturnsForStocksList[[stockIndexForSecondLoop]] <- forcastedLogReturnsForCurrentStock
  }
  
  forecastedLogReturnsForStocks <- dplyr::bind_cols(forecastedLogReturnsForStocksList)
  forecastedLogReturnsForStocks <- as.matrix.data.frame(forecastedLogReturnsForStocks)
  
  tickers <- colnames(stocksToUseForModeling)
  
  meanReturns <- colMeans(stocksToUseForModeling)
  covMat <- cov(stocksToUseForModeling)
  
  columnSumsOfStocksToUseForModeling <- as.data.frame(colSums(stocksToUseForModeling))
  # weightsForPortfolio <- as.data.frame(sweep(columnSumsOfStocksToUseForModeling,2,colSums(columnSumsOfStocksToUseForModeling),`/`))
  
  weightsForPortfolio <- data.frame(matrix(ncol = 1, nrow = 30))
  weightsForPortfolio[] <- 1/30
  
  totalReturnsForTheForecastingWindowByDay <- as.matrix(forecastedLogReturnsForStocks) %*% as.matrix(weightsForPortfolio)
  
  totalReturnForTheForecastingWindow <- unname(colSums(totalReturnsForTheForecastingWindowByDay))
  listOftotalReturnsForEachForecastedPeriod[[index+1]] <- totalReturnForTheForecastingWindow
  
  index <- index + 1
  if (index == 455)
    # if (endRow > 257)
  {
    break
  }
}

totalReturnsForEachForecastedPeriod <- dplyr::bind_cols(listOftotalReturnsForEachForecastedPeriod)
totalReturnsForEachForecastedPeriod <- as.data.frame(totalReturnsForEachForecastedPeriod)

totalReturnsForEachForecastedPeriod

write.csv(totalReturnsForEachForecastedPeriod,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\TESTForecastedPortfolioReturnsSP500.csv", row.names = FALSE)
```

```{r eval=FALSE}
options(scipen = 999)
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")

forecastedPortfolioReturns <- t(read.csv(file="TESTForecastedPortfolioReturns.csv", header=TRUE, sep=","))
forecastedPortfolioReturns[, 1]  <- as.numeric(forecastedPortfolioReturns[, 1])

forecastedPortfolioReturnsEqualWeights <- t(read.csv(file="TESTForecastedPortfolioReturnsEqualWeights.csv", header=TRUE, sep=","))
forecastedPortfolioReturnsEqualWeights[, 1]  <- as.numeric(forecastedPortfolioReturnsEqualWeights[, 1])

forecastedPortfolioReturnsSP500 <- t(read.csv(file="TESTForecastedPortfolioReturnsSP500.csv", header=TRUE, sep=","))
forecastedPortfolioReturnsSP500[, 1]  <- as.numeric(forecastedPortfolioReturnsSP500[, 1])

cumulativeForecastedPortfolioReturns <- cumsum(forecastedPortfolioReturns[, 1])
cumulativeForecastedPortfolioReturnsEqualWeights <- cumsum(forecastedPortfolioReturnsEqualWeights[, 1])
cumulativeForecastedPortfolioReturnsSP500 <- cumsum(forecastedPortfolioReturnsSP500[, 1])

plot(cumulativeForecastedPortfolioReturns,type="l",col="red", lty=1, main = "Cumulative Returns Over Time", xlab = "Time", ylab = "Cumulative Returns")
lines(cumulativeForecastedPortfolioReturnsEqualWeights,col="green", lty=1)
lines(cumulativeForecastedPortfolioReturnsSP500,col="blue", lty=1)

legend("topleft", legend=c("Forecasted Portfolio (Optimized)", "Forecasted Portfolio (Equal Weights)", "S&P 500"),
       col=c("red","green","blue"), lty=1, cex=1,bty="n")
```

```{r eval=FALSE}
options(scipen = 999)
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")

k = .0005

forecastedPortfolioReturns <- t(read.csv(file="ForecastedPROptimized.csv", header=TRUE, sep=","))
forecastedPortfolioReturns[, 1]  <- as.numeric(forecastedPortfolioReturns[, 1])

forecastedPortfolioReturnsEqualWeights <- t(read.csv(file="ForecastedPREqualWeights.csv", header=TRUE, sep=","))
forecastedPortfolioReturnsEqualWeights[, 1]  <- as.numeric(forecastedPortfolioReturnsEqualWeights[, 1])

forecastedPortfolioReturnsSP500 <- t(read.csv(file="TESTForecastedPortfolioReturnsSP500.csv", header=TRUE, sep=","))
forecastedPortfolioReturnsSP500[, 1]  <- as.numeric(forecastedPortfolioReturnsSP500[, 1])

cumulativeForecastedPortfolioReturns <- cumsum(forecastedPortfolioReturns[, 1])
cumulativeForecastedPortfolioReturnsEqualWeights <- cumsum(forecastedPortfolioReturnsEqualWeights[, 1])
cumulativeForecastedPortfolioReturnsSP500 <- cumsum(forecastedPortfolioReturnsSP500[, 1])

plot(cumulativeForecastedPortfolioReturns,type="l",col="red", lty=1, main = "Cumulative Returns Over Time", xlab = "Time", ylab = "Cumulative Returns")
lines(cumulativeForecastedPortfolioReturnsEqualWeights,col="green", lty=1)
lines(cumulativeForecastedPortfolioReturnsSP500,col="blue", lty=1)

forecastedWeights <- t(read.csv(file="ForecastedWOptimized.csv", header=TRUE, sep=","))
forecastedWeights[, 1]  <- as.numeric(forecastedWeights[, 1])
forecastedPortfolioReturns <- 1+forecastedPortfolioReturns
forecastedWeights <- (1-(k*forecastedWeights))
forecastedPortfolioReturns <- (1-(forecastedWeights*forecastedPortfolioReturns))

forecastedWeightsEqualWeights <- t(read.csv(file="ForecastedWEqualWeights.csv", header=TRUE, sep=","))
forecastedWeightsEqualWeights[, 1]  <- as.numeric(forecastedWeightsEqualWeights[, 1])
forecastedPortfolioReturnsEqualWeights <- 1+forecastedPortfolioReturnsEqualWeights
forecastedWeightsEqualWeights <- (1-(k*forecastedWeightsEqualWeights))
forecastedPortfolioReturnsEqualWeights <- (1-(forecastedWeightsEqualWeights*forecastedPortfolioReturnsEqualWeights))

cumulativeForecastedPortfolioReturns <- cumsum(forecastedPortfolioReturns[, 1])
cumulativeForecastedPortfolioReturnsEqualWeights <- cumsum(forecastedPortfolioReturnsEqualWeights[, 1])
cumulativeForecastedPortfolioReturnsSP500 <- cumsum(forecastedPortfolioReturnsSP500[, 1])

plot(cumulativeForecastedPortfolioReturns,type="l",col="red", lty=1, main = "Cumulative Returns Over Time (Transaction Consts)", xlab = "Time", ylab = "Cumulative Returns")
lines(cumulativeForecastedPortfolioReturnsEqualWeights,col="green", lty=1)
lines(cumulativeForecastedPortfolioReturnsSP500,col="blue", lty=1)

legend("topleft", legend=c("Forecasted Portfolio (Optimized)", "Forecasted Portfolio (Equal Weights)", "S&P 500"),
       col=c("red","green","blue"), lty=1, cex=1,bty="n")
```

```{r eval=TRUE}
options(scipen = 999)
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")

k = .0005
forecastedWeights <- t(read.csv(file="ForecastedWOptimized.csv", header=TRUE, sep=","))

forecastedPortfolioReturns <- t(read.csv(file="ForecastedPROptimized.csv", header=TRUE, sep=","))

priorTotals <- as.data.frame(rowSums(forecastedPortfolioReturns))

forecastedPortfolioReturns[,1] <- 1+forecastedPortfolioReturns[,1]
forecastedPortfolioReturns <- as.data.frame(forecastedPortfolioReturns)
forecastedWeights <- as.data.frame((1-(k*forecastedWeights)))

forecastedPortfolioReturns[,1] <- forecastedPortfolioReturns[,1] * forecastedWeights[match(row.names(forecastedPortfolioReturns), row.names(forecastedWeights)), 1]
forecastedPortfolioReturns[,1] <- forecastedPortfolioReturns[,1]-1

forecastedPortfolioReturns <- as.data.frame(rowSums(forecastedPortfolioReturns))

priorTotals
forecastedPortfolioReturns


forecastedPortfolioReturnsEqualWeights <- t(read.csv(file="ForecastedPREqualWeights.csv", header=TRUE, sep=","))
forecastedPortfolioReturnsEqualWeights[, 1]  <- as.numeric(forecastedPortfolioReturnsEqualWeights[, 1])

forecastedPortfolioReturnsSP500 <- t(read.csv(file="TESTForecastedPortfolioReturnsSP500.csv", header=TRUE, sep=","))
forecastedPortfolioReturnsSP500[, 1]  <- as.numeric(forecastedPortfolioReturnsSP500[, 1])

cumulativeForecastedPortfolioReturns <- cumsum(forecastedPortfolioReturns[, 1])
cumulativeForecastedPortfolioReturnsEqualWeights <- cumsum(forecastedPortfolioReturnsEqualWeights[, 1])
cumulativeForecastedPortfolioReturnsSP500 <- cumsum(forecastedPortfolioReturnsSP500[, 1])

plot(cumulativeForecastedPortfolioReturns,type="l",col="red", lty=1, main = "Cumulative Returns Over Time", xlab = "Time", ylab = "Cumulative Returns")
lines(cumulativeForecastedPortfolioReturnsEqualWeights,col="green", lty=1)
lines(cumulativeForecastedPortfolioReturnsSP500,col="blue", lty=1)



# forecastedWeights <- t(read.csv(file="ForecastedWOptimized.csv", header=TRUE, sep=","))
# forecastedWeights[, 1]  <- as.numeric(forecastedWeights[, 1])
# forecastedPortfolioReturns <- 1+forecastedPortfolioReturns
# forecastedWeights <- (1-(k*forecastedWeights))
# forecastedPortfolioReturns <- (1-(forecastedWeights*forecastedPortfolioReturns))
# 
# forecastedWeightsEqualWeights <- t(read.csv(file="ForecastedWEqualWeights.csv", header=TRUE, sep=","))
# forecastedWeightsEqualWeights[, 1]  <- as.numeric(forecastedWeightsEqualWeights[, 1])
# forecastedPortfolioReturnsEqualWeights <- 1+forecastedPortfolioReturnsEqualWeights
# forecastedWeightsEqualWeights <- (1-(k*forecastedWeightsEqualWeights))
# forecastedPortfolioReturnsEqualWeights <- (1-(forecastedWeightsEqualWeights*forecastedPortfolioReturnsEqualWeights))
# 
# cumulativeForecastedPortfolioReturns <- cumsum(forecastedPortfolioReturns[, 1])
# cumulativeForecastedPortfolioReturnsEqualWeights <- cumsum(forecastedPortfolioReturnsEqualWeights[, 1])
# cumulativeForecastedPortfolioReturnsSP500 <- cumsum(forecastedPortfolioReturnsSP500[, 1])
# 
# plot(cumulativeForecastedPortfolioReturns,type="l",col="red", lty=1, main = "Cumulative Returns Over Time (Transaction Consts)", xlab = "Time", ylab = "Cumulative Returns")
# lines(cumulativeForecastedPortfolioReturnsEqualWeights,col="green", lty=1)
# lines(cumulativeForecastedPortfolioReturnsSP500,col="blue", lty=1)
# 
# legend("topleft", legend=c("Forecasted Portfolio (Optimized)", "Forecasted Portfolio (Equal Weights)", "S&P 500"),
#        col=c("red","green","blue"), lty=1, cex=1,bty="n")
```

# Mean, Volatilty, Sharpe Ratio, Sortino Ratio, Maximum Drawdown, Turnover
```{r eval=FALSE}
options(scipen = 999)
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")

forecastedPortfolioReturns <- t(read.csv(file="TESTForecastedPortfolioReturns.csv", header=TRUE, sep=","))
forecastedPortfolioReturns[, 1]  <- as.numeric(forecastedPortfolioReturns[, 1])

forecastedPortfolioReturnsEqualWeights <- t(read.csv(file="TESTForecastedPortfolioReturnsEqualWeights.csv", header=TRUE, sep=","))
forecastedPortfolioReturnsEqualWeights[, 1]  <- as.numeric(forecastedPortfolioReturnsEqualWeights[, 1])

forecastedPortfolioReturnsSP500 <- t(read.csv(file="TESTForecastedPortfolioReturnsSP500.csv", header=TRUE, sep=","))
forecastedPortfolioReturnsSP500[, 1]  <- as.numeric(forecastedPortfolioReturnsSP500[, 1])

forecastedPortfolioReturnsTS <- ts(forecastedPortfolioReturns)
forecastedPortfolioReturnsEqualWeightsTS <- ts(forecastedPortfolioReturnsEqualWeights)
forecastedPortfolioReturnsSP500TS <- ts(forecastedPortfolioReturnsSP500)


#Mean Returns
meanForecastedPortfolioReturns <- mean(forecastedPortfolioReturns)
meanForecastedPortfolioReturnsEqualWeights <- mean(forecastedPortfolioReturnsEqualWeights)
meanForecastedPortfolioReturnsSP500 <- mean(forecastedPortfolioReturnsSP500)

print(meanForecastedPortfolioReturns)
print(meanForecastedPortfolioReturnsEqualWeights)
print(meanForecastedPortfolioReturnsSP500)

#Volatility
sdForecastedPortfolioReturns <- sd(forecastedPortfolioReturns)
sdForecastedPortfolioReturnsEqualWeights <- sd(forecastedPortfolioReturnsEqualWeights)
sdForecastedPortfolioReturnsSP500 <- sd(forecastedPortfolioReturnsSP500)

print(sdForecastedPortfolioReturns)
print(sdForecastedPortfolioReturnsEqualWeights)
print(sdForecastedPortfolioReturnsSP500)

#Sharpe Ratios
sharpeRatioForecastedPortfolioReturns <- SharpeRatio(forecastedPortfolioReturnsTS, Rf = 0, FUN="StdDev")
sharpeRatioForecastedPortfolioReturnsEqualWeights <- SharpeRatio(forecastedPortfolioReturnsEqualWeightsTS, Rf = 0, FUN="StdDev")
sharpeRatioForecastedPortfolioReturnsSP500 <- SharpeRatio(forecastedPortfolioReturnsSP500TS, Rf = 0, FUN="StdDev")

print(sharpeRatioForecastedPortfolioReturns)
print(sharpeRatioForecastedPortfolioReturnsEqualWeights)
print(sharpeRatioForecastedPortfolioReturnsSP500)

#Sortino Ratios
sortinoRatioForecastedPortfolioReturns <- SortinoRatio(forecastedPortfolioReturnsTS, MAR = 0)
sortinoRatioForecastedPortfolioReturnsEqualWeights <- SortinoRatio(forecastedPortfolioReturnsEqualWeightsTS, MAR = 0)
sortinoRatioForecastedPortfolioReturnsSP500 <- SortinoRatio(forecastedPortfolioReturnsSP500TS, MAR = 0)

print(sortinoRatioForecastedPortfolioReturns)
print(sortinoRatioForecastedPortfolioReturnsEqualWeights)
print(sortinoRatioForecastedPortfolioReturnsSP500)

#Maximum Drawdown
maximumDrawdownForecastedPortfolioReturns <- maxDrawdown(forecastedPortfolioReturnsTS)
maximumDrawdownForecastedPortfolioReturnsEqualWeights <- maxDrawdown(forecastedPortfolioReturnsEqualWeightsTS)
maximumDrawdownForecastedPortfolioReturnsSP500 <- maxDrawdown(forecastedPortfolioReturnsSP500TS)

print(maximumDrawdownForecastedPortfolioReturns)
print(maximumDrawdownForecastedPortfolioReturnsEqualWeights)
print(maximumDrawdownForecastedPortfolioReturnsSP500)

stocksUsedForEachForecastedPeriod <- read.csv(file="StocksUsedForEachForecastedPeriod.csv", header=TRUE, sep=",")

rowIndexes <- seq(1:nrow(stocksUsedForEachForecastedPeriod)-1)

listOfTurnoverRates <- list()
for (rowIndex in rowIndexes)
{
  currentRowTransposed <- as.vector(t(stocksUsedForEachForecastedPeriod[rowIndex,]))
  nextRowTransposed <- as.vector(t(stocksUsedForEachForecastedPeriod[rowIndex+1,]))
  
  uniqueStocksBetweenTheTwoRows <- as.data.frame(currentRowTransposed[!(currentRowTransposed %in% nextRowTransposed)])
  
  numberOfDifferentStocks <- nrow(uniqueStocksBetweenTheTwoRows)
  turnoverRate <- numberOfDifferentStocks/30
  listOfTurnoverRates[rowIndex] <- turnoverRate
}

turnoverRates <- dplyr::bind_cols(listOfTurnoverRates)
turnoverRates <- as.data.frame(turnoverRates)

averageTurnoverRate <- mean(as.numeric(turnoverRates))

averageTurnoverRate
```