---
title: 'GR5261 - Statistical Methods in Finance: Stocks Portfolio'
author: 
  - Jess Mathew
  - jm4742
date: "June 4, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Libraries
```{r}
library(tools)
library(zoo)
library(forecast)
library(tidyverse)
library(PerformanceAnalytics)
library(dplyr)
library(corrr)
library(tseries)
library(xts)
library(quantmod)
library(PortfolioAnalytics)
library(tsbox)
library(reshape2)
library(tfplot)
library(MASS)
library(quadprog)
library(matrixcalc)
library(Matrix)
library(BLCOP)
```

# Merge all the individual files together to create two datasets. (1) Date and Adjusted Close Price (2) Date and Volume
```{r eval=FALSE}
multMergeDateAndAdjustedClosePrice <- function(mypath) {
  filenames<-list.files(path=mypath, full.names=TRUE)
  datalist <- lapply(filenames, function(x){
    stockData <- read.csv(file=x,header=T)[,c("date", "adjclose")]
    colnames(stockData)[2] <- file_path_sans_ext(basename(x))
    return (stockData)
    })
  Reduce(function(x,y) {
    merge(x,y, by.x = "date", by.y = "date", all = TRUE)
    }, datalist)
}

multMergeDateAndVolume <- function(mypath) {
  filenames<-list.files(path=mypath, full.names=TRUE)
  datalist <- lapply(filenames, function(x){
    stockData <- read.csv(file=x,header=T)[,c("date", "volume")]
    colnames(stockData)[2] <- file_path_sans_ext(basename(x))
    return (stockData)
    })
  Reduce(function(x,y) {
    merge(x,y, by.x = "date", by.y = "date", all = TRUE)
    }, datalist)
}

dateAndAdjustedClosePriceData <- multMergeDateAndAdjustedClosePrice("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\AMEX NYSE NASDAQ Stock Histories\\fh_20190420\\full_history")

dateAndVolumeData <- multMergeDateAndVolume("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\AMEX NYSE NASDAQ Stock Histories\\fh_20190420\\full_history")

write.csv(dateAndAdjustedClosePriceData,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\DateAndAdjustedClosePriceData.csv", row.names = FALSE)

write.csv(dateAndVolumeData,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\DateAndVolumeData.csv", row.names = FALSE)
```

# Read the data files and order them by date.
```{r eval=FALSE}
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")

dateAndAdjustedClosePriceData <- read.csv(file="DateAndAdjustedClosePriceData.csv", header=TRUE, sep=",")
dateAndAdjustedClosePriceDataOrderedByDate <- dateAndAdjustedClosePriceData[order(dateAndAdjustedClosePriceData$date),]

dateAndVolumeData <- read.csv(file="DateAndVolumeData.csv", header=TRUE, sep=",")
dateAndVolumeDataOrderedByDate <- dateAndVolumeData[order(dateAndVolumeData$date),]

write.csv(dateAndAdjustedClosePriceDataOrderedByDate,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\DateAndAdjustedClosePriceDataOrderedByDate.csv", row.names = FALSE)

write.csv(dateAndVolumeDataOrderedByDate,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\DateAndVolumeDataOrderedByDate.csv", row.names = FALSE)
```

# Take the final ten years of data and remove assets which have five percent or more of the data missing. Remove assets which have less than 1,000 volume for 5% or more of the ten year period.
```{r eval=FALSE}
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")
dateAndAdjustedClosePriceDataOrderedByDate <- read.csv(file="DateAndAdjustedClosePriceDataOrderedByDate.csv", header=TRUE, sep=",")
dateAndVolumeDataOrderedByDate <- read.csv(file="DateAndVolumeDataOrderedByDate.csv", header=TRUE, sep=",")

numberOfDays <- nrow(dateAndAdjustedClosePriceDataOrderedByDate)
financialDaysInYear <- 252
financialDaysInTenYears <- financialDaysInYear*10

lastDayInTheFinalTenYearPeriod <- numberOfDays
firstDayInTheFinalTenYearPeriod <- lastDayInTheFinalTenYearPeriod - financialDaysInTenYears

dateAndAdjustedClosePriceDataOrderedByDateForFinalTenYearPeriod <- dateAndAdjustedClosePriceDataOrderedByDate[firstDayInTheFinalTenYearPeriod:lastDayInTheFinalTenYearPeriod, ]

columnNamesWithNinetyFivePercentOfAdjustedClosePriceDataAvailable <- colnames(dateAndAdjustedClosePriceDataOrderedByDateForFinalTenYearPeriod)[as.data.frame(colSums(is.na(dateAndAdjustedClosePriceDataOrderedByDateForFinalTenYearPeriod))/financialDaysInTenYears) <= 0.05]

dateAndVolumeDataOrderedByDateForFinalTenYearPeriod <- dateAndVolumeDataOrderedByDate[firstDayInTheFinalTenYearPeriod:lastDayInTheFinalTenYearPeriod, ]
dateAndVolumeDataOrderedByDateForFinalTenYearPeriod[is.na(dateAndVolumeDataOrderedByDateForFinalTenYearPeriod)] <- 0
dateAndVolumeDataOrderedByDateForFinalTenYearPeriod <- apply(dateAndVolumeDataOrderedByDateForFinalTenYearPeriod, 2, function(x) ifelse(x < 1000, "NA", x))

columnNamesWithNinetyFivePercentOfVolumeDataNotLiquid <- colnames(dateAndVolumeDataOrderedByDateForFinalTenYearPeriod)[as.data.frame(colSums(is.na(dateAndVolumeDataOrderedByDateForFinalTenYearPeriod))/financialDaysInTenYears) <= 0.05]

columnNamesForStocksThatAreVettedToUseInAnalysis <- intersect(as.vector(columnNamesWithNinetyFivePercentOfAdjustedClosePriceDataAvailable), as.vector(columnNamesWithNinetyFivePercentOfAdjustedClosePriceDataAvailable))

finalTenYearsStockHistoryForRelevantStocksConsecutiveNAValues <- subset(dateAndAdjustedClosePriceDataOrderedByDateForFinalTenYearPeriod, select=columnNamesForStocksThatAreVettedToUseInAnalysis)

write.csv(finalTenYearsStockHistoryForRelevantStocksConsecutiveNAValues,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\FinalTenYearsStockHistoryForRelevantStocksConsecutiveNAValues.csv", row.names = FALSE)
```

# Remove assets where there are too many consecutive NA values
```{r eval=FALSE}
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")
finalTenYearsStockHistoryData <- read.csv(file="FinalTenYearsStockHistoryForRelevantStocksConsecutiveNAValues.csv", header=TRUE, sep=",")

columnIndexes <- seq(1,ncol(finalTenYearsStockHistoryData))

columnIndexesWhereConsecutiveNAsAreGreaterThanOrEqualToTen <- c()
for (columnIndex in columnIndexes)
{
  stockDataForIteration <- finalTenYearsStockHistoryData[,columnIndex]
  naBreakdown <- rle(is.na(stockDataForIteration))
  if(naBreakdown$lengths >= 10 & naBreakdown$values == TRUE) {
      columnIndexesWhereConsecutiveNAsAreGreaterThanOrEqualToTen[columnIndex] <- -columnIndex
    }
}
columnIndexesWhereConsecutiveNAsAreGreaterThanOrEqualToTen <- columnIndexesWhereConsecutiveNAsAreGreaterThanOrEqualToTen[!is.na(columnIndexesWhereConsecutiveNAsAreGreaterThanOrEqualToTen)]

finalTenYearsStockHistoryData <- finalTenYearsStockHistoryData[columnIndexesWhereConsecutiveNAsAreGreaterThanOrEqualToTen]

write.csv(finalTenYearsStockHistoryData,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\FinalTenYearsStockHistoryForRelevantStocksNoNAValues.csv", row.names = FALSE)
```

# Fill in the missing NA values with reasonable estimates. For the columns where NA is the first value, we need to manually delete those. Approximately 3 columns with 10 NA values in total between the 3 columns.
```{r eval=FALSE}
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")
finalTenYearsStockHistoryData <- read.csv(file="FinalTenYearsStockHistoryForRelevantStocksNoNAValues.csv", header=TRUE, sep=",")

columnNames <- colnames(finalTenYearsStockHistoryData)

for (columnName in columnNames)
{
  finalTenYearsStockHistoryData <- finalTenYearsStockHistoryData %>% fill(columnName) #default direction down
}

write.csv(finalTenYearsStockHistoryData,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\FilteredStockHistoryDataForTheFinalTenYearsWithNoGaps.csv", row.names = FALSE)
```

# Compute the daily log returns using adjusted close prices. 
```{r eval=FALSE}
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")
finalTenYearsStockHistoryData <- read.csv(file="FilteredStockHistoryDataForTheFinalTenYearsWithNoGaps.csv", header=TRUE, sep=",", colClasses=c("Date",rep("numeric",3909)))

dailyLogReturns <- data.frame(
   cbind.data.frame(
     finalTenYearsStockHistoryData$date[-1],
     diff(as.matrix(log(finalTenYearsStockHistoryData[,-1])))
     )
   )
names(dailyLogReturns)[1]<-"date"

write.csv(dailyLogReturns,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\FullLogStockAssetDataPossibleNAValues.csv", row.names = FALSE)
```

# Need to remove columns that have too many NA values in them at this point, in the log data file. Just remove all columns with NA's in them at this point, after taking the logs.
```{r eval=FALSE}
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")
finalTenYearsStockHistoryData <- read.csv(file="FullLogStockAssetDataPossibleNAValues.csv", header=TRUE, sep=",")

finalTenYearsStockHistoryData <- finalTenYearsStockHistoryData[ , colSums(is.na(finalTenYearsStockHistoryData)) == 0]

write.csv(finalTenYearsStockHistoryData,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\FullLogStockAssetDataFilteredForNA.csv", row.names = FALSE)
```

# Detect and replace the outliers with estimates that are more consistent with the majority of the data
```{r eval=FALSE}
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")
fullLogAssetData <- read.csv(file="FullLogStockAssetDataFilteredForNA.csv", header=TRUE, sep=",", colClasses=c("Date",rep("numeric",3906)))

winsor1 <- function (x, fraction=.05)
{
   if(length(fraction) != 1 || fraction < 0 ||
         fraction > 0.5) {
      stop("bad value for 'fraction'")
   }
   lim <- quantile(x, probs=c(fraction, 1-fraction))
   x[ x < lim[1] ] <- lim[1]
   x[ x > lim[2] ] <- lim[2]
   x
}

columnIndexes <- seq(2,ncol(fullLogAssetData))

for (columnIndex in columnIndexes) {
  fullLogAssetData[,columnIndex] <- winsor1(fullLogAssetData[,columnIndex])
}

write.csv(fullLogAssetData,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\FullLogStockAssetDataFittedForOutliers.csv", row.names = FALSE)
```

# Portfolio Optimization
```{r eval=FALSE}
options(scipen = 999)
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")
fittedFullLogAssetData <- read.csv(file="FullLogStockAssetDataFittedForOutliers.csv", header=TRUE, sep=",", colClasses=c("Date",rep("numeric",3906)))[-1,]

numberOfRows <- nrow(fittedFullLogAssetData)
numberOfColumns <- ncol(fittedFullLogAssetData)

h <- 5
m <- 252

index <- 0

stockIndexesForFirstLoop <- seq(2,numberOfColumns)
listOftotalReturnsForEachForecastedPeriod <- list()
listOfTotalWeightChangeForEachForecastedPeriod <- list()

weightsForPortfolioLastIteration <- data.frame()
while (TRUE)
{
  print("While loop index")
  print(index)
  print(Sys.time())
  
  startRow <- (h*index) + 1
  endRow <- (h*index) + m
  
  assetsDataForCurrentTimePeriod <- fittedFullLogAssetData[startRow:endRow,]
  assetsDataForForecastedTimePeriod <- fittedFullLogAssetData[(endRow+1):(endRow+h),]
  
  #Sharpe Ratio Filtering
  sharpeRatiosWithStockIndex <- data.frame(Stock=character(), SharpeRatio= as.double(double()), stringsAsFactors=FALSE)[stockIndexesForFirstLoop,]

  for (stockIndexForFirstLoop in stockIndexesForFirstLoop)
  {
    currentAssetDataForStockIndex <- assetsDataForCurrentTimePeriod[,c(1,stockIndexForFirstLoop)]
    columnName <- colnames(currentAssetDataForStockIndex)[2]
    sharpeRatiosWithStockIndex[nrow(sharpeRatiosWithStockIndex)+1, ] <- c(columnName, (mean(currentAssetDataForStockIndex[,2]))/(sd(currentAssetDataForStockIndex[,2])))
  }

  stockNamesWithHighestSharpeRatios <- sharpeRatiosWithStockIndex %>% arrange(desc(SharpeRatio))
  stockNamesWithHighestSharpeRatios <- data.frame(head(stockNamesWithHighestSharpeRatios, 50))

  stocksWithHighestSharpeRatios <- subset(assetsDataForCurrentTimePeriod, select=stockNamesWithHighestSharpeRatios[,1])

  #Sortino Ratio Filtering
  sortinoRatiosWithStockIndex <- data.frame(Stock=character(), SortinoRatio= as.double(double()), stringsAsFactors=FALSE)[stockIndexesForFirstLoop,]

  for (stockIndexForFirstLoopTest in seq(2:ncol(stocksWithHighestSharpeRatios)))
  {
    currentAssetDataForStockIndex <- stocksWithHighestSharpeRatios[,c(1,stockIndexForFirstLoopTest)]
    columnName <- colnames(currentAssetDataForStockIndex)[2]

    justTesting <- currentAssetDataForStockIndex[,2]
    sortinoRatiosWithStockIndex[nrow(sortinoRatiosWithStockIndex)+1, ] <- c(columnName, (mean(justTesting))/(sd(justTesting[justTesting<0])))
  }

  stockNamesWithHighestSortinoRatios <- sortinoRatiosWithStockIndex %>% arrange(desc(SortinoRatio))
  stockNamesWithHighestSortinoRatios <- data.frame(head(stockNamesWithHighestSortinoRatios, 40))

  stocksWithHighestSortinoRatios <- subset(stocksWithHighestSharpeRatios, select=gsub(".1", "", stockNamesWithHighestSortinoRatios[,1]))
  
  #Correlation Filtering
  correlationBetweenTheStocks <- stocksWithHighestSortinoRatios %>% correlate(use = "everything") %>% stretch() %>% arrange(abs(r))

  namesOfLowlyCorrelatedStocks <- data.frame(stack(correlationBetweenTheStocks[1:2]))[,1] %>% unique()
  namesOfLowlyCorrelatedStocks <- data.frame(head(namesOfLowlyCorrelatedStocks, 30))
  
  stocksToUseForModeling <- assetsDataForCurrentTimePeriod[, as.vector(namesOfLowlyCorrelatedStocks[,1])]
  stocksToUseForModelingWithDateAppended <- data.frame(assetsDataForCurrentTimePeriod[,1], stocksToUseForModeling)
  stocksToUseForModelingXTS <- xts(stocksToUseForModelingWithDateAppended[,-1], order.by=stocksToUseForModelingWithDateAppended[,1])
  
  stockIndexesForSecondLoop <- seq(1:ncol(stocksToUseForModeling))
  actualLogReturnsForStocksList = list()
  forecastedLogReturnsForStocksList = list()
  
  for(stockIndexForSecondLoop in stockIndexesForSecondLoop) {
    print("Second loop index")
    print(stockIndexForSecondLoop)
    currentStock <- stocksToUseForModeling[stockIndexForSecondLoop]
    
    columnName <- colnames(currentStock)
    
    currentStockTS <- ts(currentStock)
    currentStockTSFitted <- auto.arima(currentStockTS)
    currentStockForecasted <- forecast(currentStockTSFitted,h=h)$mean
    
    actualLogReturnsForCurrentStock <- as.data.frame(assetsDataForForecastedTimePeriod[,columnName])
    forcastedLogReturnsForCurrentStock <- as.data.frame(currentStockForecasted)
    
    colnames(actualLogReturnsForCurrentStock)[colnames(actualLogReturnsForCurrentStock)=="assetsDataForForecastedTimePeriod[, columnName]"] <- columnName
    colnames(forcastedLogReturnsForCurrentStock)[colnames(forcastedLogReturnsForCurrentStock)=="x"] <- columnName
    
    actualLogReturnsForStocksList[[stockIndexForSecondLoop]] <- actualLogReturnsForCurrentStock
    forecastedLogReturnsForStocksList[[stockIndexForSecondLoop]] <- forcastedLogReturnsForCurrentStock
  }
  
  actualLogReturnsForStocks <- dplyr::bind_cols(actualLogReturnsForStocksList)
  actualLogReturnsForStocks <- as.matrix.data.frame(actualLogReturnsForStocks)
  
  forecastedLogReturnsForStocks <- dplyr::bind_cols(forecastedLogReturnsForStocksList)
  forecastedLogReturnsForStocks <- as.matrix.data.frame(forecastedLogReturnsForStocks)
  
  tickers <- colnames(stocksToUseForModeling)
  
  # Black Litterman Model for Portfolio Optimization
  
  meanReturnsOriginal <- as.matrix(colMeans(stocksToUseForModeling))
  covMatOriginal <- cov(stocksToUseForModeling)

  meanReturnsForecasted <- as.matrix(colMeans(forecastedLogReturnsForStocks))
  covMatForecasted <- cov(forecastedLogReturnsForStocks)
  
  tau <- 1.0
  
  meanReturns <- ginv(ginv((tau*covMatOriginal)) + ginv(covMatForecasted)) %*% ((ginv(tau*covMatOriginal) %*% meanReturnsOriginal) + (ginv(covMatForecasted) %*% meanReturnsForecasted))
  covMat <- ginv(ginv(tau*covMatOriginal)+ginv(covMatForecasted))
  
  Dmat_BL <- covMat
  dvec_BL <- rep(0,30)
  Amat_BL <- matrix(c(meanReturns,-meanReturns,rep(1,30),rep(-1,30),diag(length(meanReturns))),30,12)
  
  # compute efficient frontier for eight stocks
  varP_BL=vector()
  sigmaP_BL=vector()
  w1_BL=vector()
  w2_BL=vector()
  w3_BL=vector()
  w4_BL=vector()
  w5_BL=vector()
  w6_BL=vector()
  w7_BL=vector()
  w8_BL=vector()
  w9_BL=vector()
  w10_BL=vector()
  w11_BL=vector()
  w12_BL=vector()
  w13_BL=vector()
  w14_BL=vector()
  w15_BL=vector()
  w16_BL=vector()
  w17_BL=vector()
  w18_BL=vector()
  w19_BL=vector()
  w20_BL=vector()
  w21_BL=vector()
  w22_BL=vector()
  w23_BL=vector()
  w24_BL=vector()
  w25_BL=vector()
  w26_BL=vector()
  w27_BL=vector()
  w28_BL=vector()
  w29_BL=vector()
  w30_BL=vector()
  
  sc <- norm(Dmat_BL,"2")
  
  #Expected Returns 20 values
  Rvals_BL=seq(min(BL_matrix)+0.1^10,max(BL_matrix)-0.1^10,length.out=20)
  
  for (i in 1:length(Rvals_BL)) {
    R=Rvals_BL[i]
    bvec_BL <- c(R,-R,1,-1,0,0,0,0,0,0,0,0)
    qpSol_BL=solve.QP((nearPD(Dmat_BL)$mat)/10^6,dvec_BL/10^6,Amat_BL,bvec_BL, meq=0)
    varP_BL[i]=qpSol_BL$value
    sigmaP_BL[i]=sqrt(varP_BL[i])
    w1_BL[i]=qpSol_BL$solution[1];
    w2_BL[i]=qpSol_BL$solution[2];
    w3_BL[i]=qpSol_BL$solution[3];
    w4_BL[i]=qpSol_BL$solution[4];
    w5_BL[i]=qpSol_BL$solution[5];
    w6_BL[i]=qpSol_BL$solution[6];
    w7_BL[i]=qpSol_BL$solution[7];
    w8_BL[i]=qpSol_BL$solution[8];
    w9_BL[i]=qpSol_BL$solution[9];
    w10_BL[i]=qpSol_BL$solution[10];
    w11_BL[i]=qpSol_BL$solution[11];
    w12_BL[i]=qpSol_BL$solution[12];
    w13_BL[i]=qpSol_BL$solution[13];
    w14_BL[i]=qpSol_BL$solution[14];
    w15_BL[i]=qpSol_BL$solution[15];
    w16_BL[i]=qpSol_BL$solution[16];
    w17_BL[i]=qpSol_BL$solution[17];
    w18_BL[i]=qpSol_BL$solution[18];
    w19_BL[i]=qpSol_BL$solution[19];
    w20_BL[i]=qpSol_BL$solution[20];
    w21_BL[i]=qpSol_BL$solution[21];
    w22_BL[i]=qpSol_BL$solution[22];
    w23_BL[i]=qpSol_BL$solution[23];
    w24_BL[i]=qpSol_BL$solution[24];
    w25_BL[i]=qpSol_BL$solution[25];
    w26_BL[i]=qpSol_BL$solution[26];
    w27_BL[i]=qpSol_BL$solution[27];
    w28_BL[i]=qpSol_BL$solution[28];
    w29_BL[i]=qpSol_BL$solution[29];
    w30_BL[i]=qpSol_BL$solution[30];
  }
  
  #Portfolio weights
  weightsoutput<-data.frame(w1_BL,w2_BL,w3_BL,w4_BL,w5_BL,w6_BL,w7_BL,w8_BL,w9_BL,w10_BL,w11_BL,w12_BL,w13_BL,w14_BL,w15_BL,w16_BL,w17_BL,w18_BL,w19_BL,w20_BL,w21_BL,w22_BL,w23_BL,w24_BL,w25_BL,w26_BL,w27_BL,w28_BL,w29_BL,w30_BL)
  
  weightsForPortfolioThisIteration <- as.data.frame(colMeans(weightsoutput))
  
  weightsRowNames <- as.data.frame(tickers)
  
  for (weightsRowIndex in seq(1:nrow(weightsRowNames)))
  {
    rownames(weightsForPortfolioThisIteration)[weightsRowIndex] <- as.character(weightsRowNames[weightsRowIndex,1])
  }
  
  mergedWeightDataFrame <- merge(weightsForPortfolioLastIteration,weightsForPortfolioThisIteration, by="row.names", all = TRUE)
  mergedWeightDataFrame[is.na(mergedWeightDataFrame)] <- 0
  
  absoluteDifferenceBetweenColumns <- as.double()
  if (index>0)
  {
    absoluteDifferenceBetweenColumns <- sum(abs(mergedWeightDataFrame[,2] - mergedWeightDataFrame[,3]))
  }
  else
  {
    absoluteDifferenceBetweenColumns <- 0
  }
  listOfTotalWeightChangeForEachForecastedPeriod[[index+1]] <- absoluteDifferenceBetweenColumns
  
  weightsForPortfolioLastIteration <- weightsForPortfolioThisIteration
  
  print(weightsForPortfolioThisIteration)
  print(colSums(as.data.frame(weightsForPortfolioThisIteration)))
  
  totalReturnsForTheForecastingWindowByDay <- as.matrix(actualLogReturnsForStocks) %*% as.matrix(weightsForPortfolioThisIteration)
  
  totalReturnForTheForecastingWindow <- unname(colSums(totalReturnsForTheForecastingWindowByDay))
  listOftotalReturnsForEachForecastedPeriod[[index+1]] <- totalReturnsForTheForecastingWindowByDay
  
  index <- index + 1
  if (index == 453)
    # if (endRow > 257)
  {
    break
  }
}

totalReturnsForEachForecastedPeriod <- dplyr::bind_cols(listOftotalReturnsForEachForecastedPeriod)
totalReturnsForEachForecastedPeriod <- as.data.frame(totalReturnsForEachForecastedPeriod)

totalReturnsForEachForecastedPeriod

totalWeightChangesForEachForecastedPeriod <- dplyr::bind_cols(listOfTotalWeightChangeForEachForecastedPeriod)
totalWeightChangesForEachForecastedPeriod <- as.data.frame(totalWeightChangesForEachForecastedPeriod)

totalWeightChangesForEachForecastedPeriod

write.csv(totalReturnsForEachForecastedPeriod,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\ForecastedPROptimized.csv", row.names = FALSE)
write.csv(totalWeightChangesForEachForecastedPeriod,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\ForecastedWOptimized.csv", row.names = FALSE)
```

# Portfolio Optimization with Equal Weights
```{r eval=FALSE}
options(scipen = 999)
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")
fittedFullLogAssetData <- read.csv(file="FullLogStockAssetDataFittedForOutliers.csv", header=TRUE, sep=",", colClasses=c("Date",rep("numeric",3906)))[-1,]

numberOfRows <- nrow(fittedFullLogAssetData)
numberOfColumns <- ncol(fittedFullLogAssetData)

h <- 5
m <- 252

index <- 0

stockIndexesForFirstLoop <- seq(2,numberOfColumns)
listOftotalReturnsForEachForecastedPeriod <- list()
listOfTotalWeightChangeForEachForecastedPeriod <- list()

weightsForPortfolioLastIteration <- data.frame()
while (TRUE)
{
  print("While loop index")
  print(index)
  print(Sys.time())
  
  startRow <- (h*index) + 1
  endRow <- (h*index) + m
  
  assetsDataForCurrentTimePeriod <- fittedFullLogAssetData[startRow:endRow,]
  assetsDataForForecastedTimePeriod <- fittedFullLogAssetData[(endRow+1):(endRow+h),]
  
  #Sharpe Ratio Filtering
  sharpeRatiosWithStockIndex <- data.frame(Stock=character(), SharpeRatio= as.double(double()), stringsAsFactors=FALSE)[stockIndexesForFirstLoop,]
  
  for (stockIndexForFirstLoop in stockIndexesForFirstLoop)
  {
    currentAssetDataForStockIndex <- assetsDataForCurrentTimePeriod[,c(1,stockIndexForFirstLoop)]
    columnName <- colnames(currentAssetDataForStockIndex)[2]
    sharpeRatiosWithStockIndex[nrow(sharpeRatiosWithStockIndex)+1, ] <- c(columnName, (mean(currentAssetDataForStockIndex[,2]))/(sd(currentAssetDataForStockIndex[,2])))
  }
  
  stockNamesWithHighestSharpeRatios <- sharpeRatiosWithStockIndex %>% arrange(desc(SharpeRatio))
  stockNamesWithHighestSharpeRatios <- data.frame(head(stockNamesWithHighestSharpeRatios, 50))
  
  stocksWithHighestSharpeRatios <- subset(assetsDataForCurrentTimePeriod, select=stockNamesWithHighestSharpeRatios[,1])
  
  #Sortino Ratio Filtering
  sortinoRatiosWithStockIndex <- data.frame(Stock=character(), SortinoRatio= as.double(double()), stringsAsFactors=FALSE)[stockIndexesForFirstLoop,]
  
  for (stockIndexForFirstLoopTest in seq(2:ncol(stocksWithHighestSharpeRatios)))
  {
    currentAssetDataForStockIndex <- stocksWithHighestSharpeRatios[,c(1,stockIndexForFirstLoopTest)]
    columnName <- colnames(currentAssetDataForStockIndex)[2]
    
    justTesting <- currentAssetDataForStockIndex[,2]
    sortinoRatiosWithStockIndex[nrow(sortinoRatiosWithStockIndex)+1, ] <- c(columnName, (mean(justTesting))/(sd(justTesting[justTesting<0])))
  }
  
  stockNamesWithHighestSortinoRatios <- sortinoRatiosWithStockIndex %>% arrange(desc(SortinoRatio))
  stockNamesWithHighestSortinoRatios <- data.frame(head(stockNamesWithHighestSortinoRatios, 40))
  
  stocksWithHighestSortinoRatios <- subset(stocksWithHighestSharpeRatios, select=gsub(".1", "", stockNamesWithHighestSortinoRatios[,1]))
  
  # #Sortino Ratio Filtering TEST
  # sortinoRatiosWithStockIndex <- data.frame(Stock=character(), SortinoRatio= as.double(double()), stringsAsFactors=FALSE)[stockIndexesForFirstLoop,]
  # 
  # for (stockIndexForFirstLoop in stockIndexesForFirstLoop)
  # {
  #   currentAssetDataForStockIndex <- assetsDataForCurrentTimePeriod[,c(1,stockIndexForFirstLoop)]
  #   columnName <- colnames(currentAssetDataForStockIndex)[2]
  # 
  #   justTesting <- currentAssetDataForStockIndex[,2]
  #   sortinoRatiosWithStockIndex[nrow(sortinoRatiosWithStockIndex)+1, ] <- c(columnName, (mean(justTesting))/(sd(justTesting[justTesting<0])))
  # }
  # 
  # stockNamesWithHighestSortinoRatios <- sortinoRatiosWithStockIndex %>% arrange(desc(SortinoRatio))
  # stockNamesWithHighestSortinoRatios <- data.frame(head(stockNamesWithHighestSortinoRatios, 30))
  # 
  # stocksWithHighestSortinoRatios <- subset(assetsDataForCurrentTimePeriod, select=stockNamesWithHighestSortinoRatios[,1])
  
  #Correlation Filtering
  correlationBetweenTheStocks <- stocksWithHighestSortinoRatios %>% correlate(use = "everything") %>% stretch() %>% arrange(abs(r))
  
  namesOfLowlyCorrelatedStocks <- data.frame(stack(correlationBetweenTheStocks[1:2]))[,1] %>% unique()
  namesOfLowlyCorrelatedStocks <- data.frame(head(namesOfLowlyCorrelatedStocks, 30))
  
  stocksToUseForModeling <- assetsDataForCurrentTimePeriod[, as.vector(namesOfLowlyCorrelatedStocks[,1])]
  stocksToUseForModelingWithDateAppended <- data.frame(assetsDataForCurrentTimePeriod[,1], stocksToUseForModeling)
  stocksToUseForModelingXTS <- xts(stocksToUseForModelingWithDateAppended[,-1], order.by=stocksToUseForModelingWithDateAppended[,1])
  
  stockIndexesForSecondLoop <- seq(1:ncol(stocksToUseForModeling))
  forecastedLogReturnsForStocksList = list()
  
  for(stockIndexForSecondLoop in stockIndexesForSecondLoop) {
    print("Second loop index")
    print(stockIndexForSecondLoop)
    currentStock <- stocksToUseForModeling[stockIndexForSecondLoop]
    
    columnName <- colnames(currentStock)
    
    currentStockTS <- ts(currentStock)
    currentStockTSFitted <- auto.arima(currentStockTS)
    currentStockForecasted <- forecast(currentStockTSFitted,h=h)$mean
    forcastedLogReturnsForCurrentStock <- as.data.frame(assetsDataForForecastedTimePeriod[,columnName])
    
    colnames(forcastedLogReturnsForCurrentStock)[colnames(forcastedLogReturnsForCurrentStock)=="assetsDataForForecastedTimePeriod[, columnName]"] <- columnName
    forecastedLogReturnsForStocksList[[stockIndexForSecondLoop]] <- forcastedLogReturnsForCurrentStock
  }
  
  forecastedLogReturnsForStocks <- dplyr::bind_cols(forecastedLogReturnsForStocksList)
  forecastedLogReturnsForStocks <- as.matrix.data.frame(forecastedLogReturnsForStocks)
  
  tickers <- colnames(stocksToUseForModeling)
  
  # Equal Weights for Portfolio Optimization
  
  weightsForPortfolioThisIteration <- data.frame(matrix(ncol = 1, nrow = 30))
  weightsForPortfolioThisIteration[] <- 1/30
  
  weightsRowNames <- as.data.frame(tickers)
  
  for (weightsRowIndex in seq(1:nrow(weightsRowNames)))
  {
    rownames(weightsForPortfolioThisIteration)[weightsRowIndex] <- as.character(weightsRowNames[weightsRowIndex,1])
  }
  
  mergedWeightDataFrame <- merge(weightsForPortfolioLastIteration,weightsForPortfolioThisIteration, by="row.names", all = TRUE)
  mergedWeightDataFrame[is.na(mergedWeightDataFrame)] <- 0
  
  absoluteDifferenceBetweenColumns <- as.double()
  if (index>0)
  {
    absoluteDifferenceBetweenColumns <- sum(abs(mergedWeightDataFrame[,2] - mergedWeightDataFrame[,3]))
  }
  else
  {
    absoluteDifferenceBetweenColumns <- 0
  }
  listOfTotalWeightChangeForEachForecastedPeriod[[index+1]] <- absoluteDifferenceBetweenColumns
  
  weightsForPortfolioLastIteration <- weightsForPortfolioThisIteration
  
  print(weightsForPortfolioThisIteration)
  print(colSums(as.data.frame(weightsForPortfolioThisIteration)))
  
  totalReturnsForTheForecastingWindowByDay <- as.matrix(forecastedLogReturnsForStocks) %*% as.matrix(weightsForPortfolioThisIteration)
  
  totalReturnForTheForecastingWindow <- unname(colSums(totalReturnsForTheForecastingWindowByDay))
  listOftotalReturnsForEachForecastedPeriod[[index+1]] <- totalReturnsForTheForecastingWindowByDay
  
  index <- index + 1
  if (index == 453)
    # if (endRow > 257)
  {
    break
  }
}

totalReturnsForEachForecastedPeriod <- dplyr::bind_cols(listOftotalReturnsForEachForecastedPeriod)
totalReturnsForEachForecastedPeriod <- as.data.frame(totalReturnsForEachForecastedPeriod)

totalReturnsForEachForecastedPeriod

totalWeightChangesForEachForecastedPeriod <- dplyr::bind_cols(listOfTotalWeightChangeForEachForecastedPeriod)
totalWeightChangesForEachForecastedPeriod <- as.data.frame(totalWeightChangesForEachForecastedPeriod)

totalWeightChangesForEachForecastedPeriod

write.csv(totalReturnsForEachForecastedPeriod,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\ForecastedPREqualWeights.csv", row.names = FALSE)
write.csv(totalWeightChangesForEachForecastedPeriod,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\ForecastedWEqualWeights.csv", row.names = FALSE)
``` 

# Portfolio Optimization for S&P500
```{r eval=FALSE}
options(scipen = 999)
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")

sp500StockData <- read.csv(file = "SP500new.csv", header=TRUE, sep=",", colClasses=c("Date",rep("numeric",5)))

numberOfDays <- nrow(sp500StockData)
financialDaysInYear <- 252
financialDaysInTenYears <- financialDaysInYear*10

lastDayInTheFinalTenYearPeriod <- numberOfDays
firstDayInTheFinalTenYearPeriod <- lastDayInTheFinalTenYearPeriod - financialDaysInTenYears

sp500StockDataForFinalTenYearPeriod <- sp500StockData[firstDayInTheFinalTenYearPeriod:lastDayInTheFinalTenYearPeriod, c(1, 4)]

fittedFullLogSP500StockData <- data.frame(
  cbind.data.frame(
    sp500StockDataForFinalTenYearPeriod$Date[-1],
    diff(as.matrix(log(sp500StockDataForFinalTenYearPeriod[,-1])))
  )
)
names(sp500StockDataForFinalTenYearPeriod)[1]<-"date"

head(fittedFullLogSP500StockData)
dim(fittedFullLogSP500StockData)

fittedFullLogAssetData = cbind(fittedFullLogSP500StockData, replicate(30,fittedFullLogSP500StockData[,2]))

head(fittedFullLogAssetData)

# fittedFullLogAssetData <- read.csv(file="FullLogStockAssetDataFittedForOutliers.csv", header=TRUE, sep=",", colClasses=c("Date",rep("numeric",3906)))[-1,]
numberOfRows <- nrow(fittedFullLogAssetData)
numberOfColumns <- ncol(fittedFullLogAssetData)

h <- 5
m <- 252

# breakingCondition <- numberOfRows + h

index <- 0

stockIndexesForFirstLoop <- seq(2,numberOfColumns)
listOftotalReturnsForEachForecastedPeriod <- list()
while (TRUE)
{
  print("While loop index")
  print(index)
  print(Sys.time())
  startRow <- (h*index) + 1
  endRow <- (h*index) + m
  
  assetsDataForCurrentTimePeriod <- fittedFullLogAssetData[startRow:endRow,]
  assetsDataForForecastedTimePeriod <- fittedFullLogAssetData[(endRow+1):(endRow+h),]
  
  sharpeRatiosWithStockIndex <- data.frame(Stock=character(), SharpeRatio= as.double(double()), stringsAsFactors=FALSE)[stockIndexesForFirstLoop,]
  
  for (stockIndexForFirstLoop in stockIndexesForFirstLoop)
  {
    currentAssetDataForStockIndex <- assetsDataForCurrentTimePeriod[,c(1,stockIndexForFirstLoop)]
    columnName <- colnames(currentAssetDataForStockIndex)[2]
    sharpeRatiosWithStockIndex[nrow(sharpeRatiosWithStockIndex)+1, ] <- c(columnName, (mean(currentAssetDataForStockIndex[,2]))/(sd(currentAssetDataForStockIndex[,2])))
  }
  
  stockNamesWithHighestSharpeRatios <- sharpeRatiosWithStockIndex %>% arrange(desc(SharpeRatio))
  stockNamesWithHighestSharpeRatios <- data.frame(head(stockNamesWithHighestSharpeRatios, 30))
  
  stocksWithHighestSharpeRatios <- subset(assetsDataForCurrentTimePeriod, select=stockNamesWithHighestSharpeRatios[,1])
  
  correlationBetweenTheStocks <- stocksWithHighestSharpeRatios %>% correlate(use = "everything") %>% stretch() %>% arrange(abs(r))
  
  namesOfLowlyCorrelatedStocks <- data.frame(stack(correlationBetweenTheStocks[1:2]))[,1] %>% unique()
  namesOfLowlyCorrelatedStocks <- data.frame(head(namesOfLowlyCorrelatedStocks, 30))
  
  stocksToUseForModeling <- assetsDataForCurrentTimePeriod[, as.vector(namesOfLowlyCorrelatedStocks[,1])]
  stocksToUseForModelingWithDateAppended <- data.frame(assetsDataForCurrentTimePeriod[,1], stocksToUseForModeling)
  stocksToUseForModelingXTS <- xts(stocksToUseForModelingWithDateAppended[,-1], order.by=stocksToUseForModelingWithDateAppended[,1])
  
  stockIndexesForSecondLoop <- seq(1:ncol(stocksToUseForModeling))
  forecastedLogReturnsForStocksList = list()
  
  for(stockIndexForSecondLoop in stockIndexesForSecondLoop) {
    print("Second loop index")
    print(stockIndexForSecondLoop)
    currentStock <- stocksToUseForModeling[stockIndexForSecondLoop]
    
    columnName <- colnames(currentStock)
    
    currentStockTS <- ts(currentStock)
    currentStockTSFitted <- auto.arima(currentStockTS)
    currentStockForecasted <- forecast(currentStockTSFitted,h=h)$mean
    forcastedLogReturnsForCurrentStock <- as.data.frame(assetsDataForForecastedTimePeriod[,columnName])
    
    colnames(forcastedLogReturnsForCurrentStock)[colnames(forcastedLogReturnsForCurrentStock)=="x"] <- columnName
    forecastedLogReturnsForStocksList[[stockIndexForSecondLoop]] <- forcastedLogReturnsForCurrentStock
  }
  
  forecastedLogReturnsForStocks <- dplyr::bind_cols(forecastedLogReturnsForStocksList)
  forecastedLogReturnsForStocks <- as.matrix.data.frame(forecastedLogReturnsForStocks)
  
  tickers <- colnames(stocksToUseForModeling)
  
  meanReturns <- colMeans(stocksToUseForModeling)
  covMat <- cov(stocksToUseForModeling)
  
  columnSumsOfStocksToUseForModeling <- as.data.frame(colSums(stocksToUseForModeling))
  
  weightsForPortfolio <- data.frame(matrix(ncol = 1, nrow = 30))
  weightsForPortfolio[] <- 1/30
  
  totalReturnsForTheForecastingWindowByDay <- as.matrix(forecastedLogReturnsForStocks) %*% as.matrix(weightsForPortfolio)
  
  totalReturnForTheForecastingWindow <- unname(colSums(totalReturnsForTheForecastingWindowByDay))
  listOftotalReturnsForEachForecastedPeriod[[index+1]] <- totalReturnForTheForecastingWindow
  
  index <- index + 1
  if (index == 453)
    # if (endRow > 257)
  {
    break
  }
}

totalReturnsForEachForecastedPeriod <- dplyr::bind_cols(listOftotalReturnsForEachForecastedPeriod)
totalReturnsForEachForecastedPeriod <- as.data.frame(totalReturnsForEachForecastedPeriod)

totalReturnsForEachForecastedPeriod

write.csv(totalReturnsForEachForecastedPeriod,"C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files\\ForecastedPRSP500.csv", row.names = FALSE)
```

```{r eval=TRUE}
options(scipen = 999)
setwd("C:\\Users\\jessm\\OneDrive\\Documents\\Columbia University\\Summer 2019\\GR5261 - Statistical Methods in Finance\\Take Home Project\\Final Data Files")

## Optimized Portfolio

# Read Data
k = .0005
forecastedWeights <- t(read.csv(file="ForecastedWOptimized.csv", header=TRUE, sep=","))
forecastedWeightsForTurnoverCalculations <- forecastedWeights
forecastedPortfolioReturnsTransactionCosts <- t(read.csv(file="ForecastedPROptimized.csv", header=TRUE, sep=","))

# Store the portfolio data before modifying for transaction costs.
forecastedPortfolioReturns <- forecastedPortfolioReturnsTransactionCosts

# Account for transaction costs against our portfolio returns. Only the first day of the h step is penalized.
forecastedPortfolioReturnsTransactionCosts[,1] <- 1+forecastedPortfolioReturnsTransactionCosts[,1]
forecastedPortfolioReturnsTransactionCosts <- as.data.frame(forecastedPortfolioReturnsTransactionCosts)
forecastedWeights <- as.data.frame((1-(k*forecastedWeights)))
forecastedPortfolioReturnsTransactionCosts[,1] <- forecastedPortfolioReturnsTransactionCosts[,1] * forecastedWeights[match(row.names(forecastedPortfolioReturnsTransactionCosts), row.names(forecastedWeights)), 1]
forecastedPortfolioReturnsTransactionCosts[,1] <- forecastedPortfolioReturnsTransactionCosts[,1]-1

# Sum each forecasting windows returns together so we have one value instead of h values.
forecastedPortfolioReturnsTransactionCosts <- as.data.frame(rowSums(forecastedPortfolioReturnsTransactionCosts))
forecastedPortfolioReturns <- as.data.frame(rowSums(forecastedPortfolioReturns))

## Equal Weights

# Read Data
k = .0005
forecastedWeightsEqualWeights <- t(read.csv(file="ForecastedWEqualWeights.csv", header=TRUE, sep=","))
forecastedWeightsEqualWeightsForTurnoverCalculations <- forecastedWeightsEqualWeights
forecastedPortfolioReturnsEqualWeightsTransactionCosts <- t(read.csv(file="ForecastedPREqualWeights.csv", header=TRUE, sep=","))

# Store the portfolio data before modifying for transaction costs.
forecastedPortfolioReturnsEqualWeights <- forecastedPortfolioReturnsEqualWeightsTransactionCosts

# Account for transaction costs against our portfolio returns. Only the first day of the h step is penalized.
forecastedPortfolioReturnsEqualWeightsTransactionCosts[,1] <- 1+forecastedPortfolioReturnsEqualWeightsTransactionCosts[,1]
forecastedPortfolioReturnsEqualWeightsTransactionCosts <- as.data.frame(forecastedPortfolioReturnsEqualWeightsTransactionCosts)
forecastedWeightsEqualWeights <- as.data.frame((1-(k*forecastedWeightsEqualWeights)))
forecastedPortfolioReturnsEqualWeightsTransactionCosts[,1] <- forecastedPortfolioReturnsEqualWeightsTransactionCosts[,1] * forecastedWeightsEqualWeights[match(row.names(forecastedPortfolioReturnsEqualWeightsTransactionCosts), row.names(forecastedWeightsEqualWeights)), 1]
forecastedPortfolioReturnsEqualWeightsTransactionCosts[,1] <- forecastedPortfolioReturnsEqualWeightsTransactionCosts[,1]-1

# Sum each forecasting windows returns together so we have one value instead of h values.
forecastedPortfolioReturnsEqualWeightsTransactionCosts <- as.data.frame(rowSums(forecastedPortfolioReturnsEqualWeightsTransactionCosts))
forecastedPortfolioReturnsEqualWeights <- as.data.frame(rowSums(forecastedPortfolioReturnsEqualWeights))

## S&P 500
forecastedPortfolioReturnsSP500 <- t(read.csv(file="ForecastedPRSP500.csv", header=TRUE, sep=","))

### Cumulative Forecasted Values to be Graphed
cumulativeForecastedPortfolioReturns <- ts(cumsum(forecastedPortfolioReturns[, 1]))
cumulativeForecastedPortfolioReturnsTransactionCosts <- ts(cumsum(forecastedPortfolioReturnsTransactionCosts[, 1]))
cumulativeForecastedPortfolioReturnsEqualWeights <- ts(cumsum(forecastedPortfolioReturnsEqualWeights[, 1]))
cumulativeForecastedPortfolioReturnsEqualWeightsTransactionCosts <- ts(cumsum(forecastedPortfolioReturnsEqualWeightsTransactionCosts[, 1]))
cumulativeForecastedPortfolioReturnsSP500 <- ts(cumsum(forecastedPortfolioReturnsSP500[, 1]))

## Plot

finalPlot <- ts.plot(cumulativeForecastedPortfolioReturns, cumulativeForecastedPortfolioReturnsTransactionCosts, cumulativeForecastedPortfolioReturnsEqualWeights, cumulativeForecastedPortfolioReturnsEqualWeightsTransactionCosts, cumulativeForecastedPortfolioReturnsSP500, gpars=list(col=c("red","orange","blue","green","black")))

legend("topleft", legend=c("Optimized", "Optimized (Transaction Costs)", "Equal Weights", "Equal Weights (Transaction Costs)", "S&P 500"),
       col=c("red","orange","blue","green","black"), lty=1, cex=1,bty="n")

## Mean, Volatilty, Sharpe Ratio, Sortino Ratio, Maximum Drawdown, Turnover

forecastedPortfolioReturnsTS <- ts(forecastedPortfolioReturns)
forecastedPortfolioReturnsTransactionCostsTS <- ts(forecastedPortfolioReturnsTransactionCosts)
forecastedPortfolioReturnsEqualWeightsTS <- ts(forecastedPortfolioReturnsEqualWeights)
forecastedPortfolioReturnsEqualWeightsTransactionCostsTS <- ts(forecastedPortfolioReturnsEqualWeightsTransactionCosts)
forecastedPortfolioReturnsSP500TS <- ts(forecastedPortfolioReturnsSP500)

# Mean
meanForecastedPortfolioReturns <- mean(forecastedPortfolioReturns[,1])
meanForecastedPortfolioReturnsTransactionCosts <- mean(forecastedPortfolioReturnsTransactionCosts[,1])
meanForecastedPortfolioReturnsEqualWeights <- mean(forecastedPortfolioReturnsEqualWeights[,1])
meanForecastedPortfolioReturnsEqualWeightsTransactionCosts <- mean(forecastedPortfolioReturnsEqualWeightsTransactionCosts[,1])
meanForecastedPortfolioReturnsSP500 <- mean(forecastedPortfolioReturnsSP500[,1])

meanForecastedPortfolioReturns
meanForecastedPortfolioReturnsTransactionCosts
meanForecastedPortfolioReturnsEqualWeights
meanForecastedPortfolioReturnsEqualWeightsTransactionCosts
meanForecastedPortfolioReturnsSP500

# Volatility
sdForecastedPortfolioReturns <- sd(forecastedPortfolioReturns[,1])
sdForecastedPortfolioReturnsTransactionCosts <- sd(forecastedPortfolioReturnsTransactionCosts[,1])
sdForecastedPortfolioReturnsEqualWeights <- sd(forecastedPortfolioReturnsEqualWeights[,1])
sdForecastedPortfolioReturnsEqualWeightsTransactionCosts <- sd(forecastedPortfolioReturnsEqualWeightsTransactionCosts[,1])
sdForecastedPortfolioReturnsSP500 <- sd(forecastedPortfolioReturnsSP500[,1])

sdForecastedPortfolioReturns
sdForecastedPortfolioReturnsTransactionCosts
sdForecastedPortfolioReturnsEqualWeights
sdForecastedPortfolioReturnsEqualWeightsTransactionCosts
sdForecastedPortfolioReturnsSP500

# Sharpe Ratio
sharpeRatioForecastedPortfolioReturns <- SharpeRatio(forecastedPortfolioReturnsTS, Rf = 0, FUN="StdDev")
sharpeRatioForecastedPortfolioReturnsTransactionCosts <- SharpeRatio(forecastedPortfolioReturnsTransactionCostsTS, Rf = 0, FUN="StdDev")
sharpeRatioForecastedPortfolioReturnsEqualWeights <- SharpeRatio(forecastedPortfolioReturnsEqualWeightsTS, Rf = 0, FUN="StdDev")
sharpeRatioForecastedPortfolioReturnsEqualWeightsTransactionCosts <- SharpeRatio(forecastedPortfolioReturnsEqualWeightsTransactionCostsTS, Rf = 0, FUN="StdDev")
sharpeRatioForecastedPortfolioReturnsSP500 <- SharpeRatio(forecastedPortfolioReturnsSP500TS, Rf = 0, FUN="StdDev")

sharpeRatioForecastedPortfolioReturns
sharpeRatioForecastedPortfolioReturnsTransactionCosts
sharpeRatioForecastedPortfolioReturnsEqualWeights
sharpeRatioForecastedPortfolioReturnsEqualWeightsTransactionCosts
sharpeRatioForecastedPortfolioReturnsSP500

# Sortino Ratio
sortinoRatioForecastedPortfolioReturns <- SortinoRatio(forecastedPortfolioReturnsTS, MAR = 0)
sortinoRatioForecastedPortfolioReturnsTransactionCosts <- SortinoRatio(forecastedPortfolioReturnsTransactionCostsTS, MAR = 0)
sortinoRatioForecastedPortfolioReturnsEqualWeights <- SortinoRatio(forecastedPortfolioReturnsEqualWeightsTS, MAR = 0)
sortinoRatioForecastedPortfolioReturnsEqualWeightsTransactionCosts <- SortinoRatio(forecastedPortfolioReturnsEqualWeightsTransactionCostsTS, MAR = 0)
sortinoRatioForecastedPortfolioReturnsSP500 <- SortinoRatio(forecastedPortfolioReturnsSP500TS, MAR = 0)

sortinoRatioForecastedPortfolioReturns
sortinoRatioForecastedPortfolioReturnsTransactionCosts
sortinoRatioForecastedPortfolioReturnsEqualWeights
sortinoRatioForecastedPortfolioReturnsEqualWeightsTransactionCosts
sortinoRatioForecastedPortfolioReturnsSP500

#Maximum Drawdown
maximumDrawdownForecastedPortfolioReturns <- maxDrawdown(forecastedPortfolioReturnsTS)
maximumDrawdownForecastedPortfolioReturnsTransactionCosts <- maxDrawdown(forecastedPortfolioReturnsTransactionCostsTS)
maximumDrawdownForecastedPortfolioReturnsEqualWeights <- maxDrawdown(forecastedPortfolioReturnsEqualWeightsTS)
maximumDrawdownForecastedPortfolioReturnsEqualWeightsTransactionCosts <- maxDrawdown(forecastedPortfolioReturnsEqualWeightsTransactionCostsTS)
maximumDrawdownForecastedPortfolioReturnsSP500 <- maxDrawdown(forecastedPortfolioReturnsSP500TS)

maximumDrawdownForecastedPortfolioReturns
maximumDrawdownForecastedPortfolioReturnsTransactionCosts
maximumDrawdownForecastedPortfolioReturnsEqualWeights
maximumDrawdownForecastedPortfolioReturnsEqualWeightsTransactionCosts
maximumDrawdownForecastedPortfolioReturnsSP500

#Turnover
forecastedWeightsForTurnoverCalculations <- ts(forecastedWeightsForTurnoverCalculations)
turnoverOptimized <- mean(as.data.frame(abs(percentChange(forecastedWeightsForTurnoverCalculations) / 100))[-1,1])

forecastedWeightsEqualWeightsForTurnoverCalculations <- ts(forecastedWeightsEqualWeightsForTurnoverCalculations)
turnoverEqualWeights <- mean(as.data.frame(abs(percentChange(forecastedWeightsEqualWeightsForTurnoverCalculations) / 100))[-1,1])

turnoverOptimized
turnoverEqualWeights
```